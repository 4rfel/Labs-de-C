{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Bem vindo aos Laborat\u00f3rios de C \u00b6 Curso: Engenharia Da Computa\u00e7\u00e3o - Quinto Semestre Disciplinas: Computa\u00e7\u00e3o Embarcada/ Sistemas HW/SW e Desafios de Programa\u00e7\u00e3o Equipe: Rafael Corsi/ Igor Montagner/ Marcelo Hasimoto/ Eduardo Marossi/ Marco Mello \u00a9 Todos os direitos reservados Objetivos \u00b6 Capacitar os alunos na linguagem C para que possam usar nas disciplinas do Quinto Semestre da Eng. Computa\u00e7\u00e3o Insper. Motiva\u00e7\u00e3o \u00b6 C possui uma excelente performance \u00c9 uma das linguagens mais utilizadas no mundo: https://spectrum.ieee.org/static/interactive-the-top-programming-languages-2019 https://githut.info/ \u00c9 baixo n\u00edvel Pesquisa \u00b6 MONTAGNER, I. S.; FERRAO, R. C. ; MAROSSI, E. ; AYRES, F. J. . Teaching C programming in context: a joint effort between the Computer Systems, Embedded Computing and Programming Challenges courses. In: IEEE Frontiers in Education Conference (FIE), 2019, Cincinatti. 2019 IEEE Frontiers in Education Conference (FIE) Proceedings, 2019.","title":"Home"},{"location":"#bem-vindo-aos-laboratorios-de-c","text":"Curso: Engenharia Da Computa\u00e7\u00e3o - Quinto Semestre Disciplinas: Computa\u00e7\u00e3o Embarcada/ Sistemas HW/SW e Desafios de Programa\u00e7\u00e3o Equipe: Rafael Corsi/ Igor Montagner/ Marcelo Hasimoto/ Eduardo Marossi/ Marco Mello \u00a9 Todos os direitos reservados","title":"Bem vindo aos Laborat\u00f3rios de C"},{"location":"#objetivos","text":"Capacitar os alunos na linguagem C para que possam usar nas disciplinas do Quinto Semestre da Eng. Computa\u00e7\u00e3o Insper.","title":"Objetivos"},{"location":"#motivacao","text":"C possui uma excelente performance \u00c9 uma das linguagens mais utilizadas no mundo: https://spectrum.ieee.org/static/interactive-the-top-programming-languages-2019 https://githut.info/ \u00c9 baixo n\u00edvel","title":"Motiva\u00e7\u00e3o"},{"location":"#pesquisa","text":"MONTAGNER, I. S.; FERRAO, R. C. ; MAROSSI, E. ; AYRES, F. J. . Teaching C programming in context: a joint effort between the Computer Systems, Embedded Computing and Programming Challenges courses. In: IEEE Frontiers in Education Conference (FIE), 2019, Cincinatti. 2019 IEEE Frontiers in Education Conference (FIE) Proceedings, 2019.","title":"Pesquisa"},{"location":"Lab1/","text":"Lab 1 - Conceitos B\u00e1sicos \u00b6 Note Por favor, fa\u00e7am esta atividade em dupla . Note Esse laborat\u00f3rio deve ser realizado com a mesma infra do day-one: AtmelStudio, kit de desenvolvimento de embarcados e LCD. Introdu\u00e7\u00e3o \u00b6 N\u00e3o \u00e9 f\u00e1cil prever o quanto a linguagem C ser\u00e1 uma novidade para voc\u00eas. Por um lado, a sintaxe \u00e9 muito parecida com Java. Por outro lado, existem diferen\u00e7as importantes e voc\u00eas est\u00e3o longe de Java h\u00e1 mais ou menos meio semestre... Vamos come\u00e7ar com a revis\u00e3o de alguns conceitos bem b\u00e1sicos. Procure, mais ou menos na metade do arquivo main.c , a fun\u00e7\u00e3o process_pixel . int process_pixel ( int level ) { int new_level ; new_level = level ; return new_level ; } Essa fun\u00e7\u00e3o \u00e9 trivial, mas no c\u00f3digo j\u00e1 vemos v\u00e1rios conceitos importantes: as instru\u00e7\u00f5es terminam em ponto-e-v\u00edrgula, como em Java; new_level \u00e9 uma vari\u00e1vel da fun\u00e7\u00e3o e precisa ser declarada para poder ser usada, como em Java; valores e vari\u00e1veis possuem tipo , pois C \u00e9 uma linguagem com tipagem forte , como Java; a declara\u00e7\u00e3o de uma vari\u00e1vel segue a sintaxe tipo nome , como em Java; int \u00e9 o tipo que representa n\u00fameros inteiros, como em Java; como tipagem forte significa que tudo , sem exce\u00e7\u00e3o, tem tipo, int tamb\u00e9m aparece antes da declara\u00e7\u00e3o do par\u00e2metro level , indicando que esse par\u00e2metro \u00e9 um n\u00famero inteiro, e antes do pr\u00f3prio nome da fun\u00e7\u00e3o, indicando que process_pixel devolve um n\u00famero inteiro; essa devolu\u00e7\u00e3o, ali\u00e1s, \u00e9 feita atrav\u00e9s da instru\u00e7\u00e3o return , como em Python e Java; tamb\u00e9m em comum com Python e Java, temos o operador = de atribui\u00e7\u00e3o. Na verdade, soa um pouco injusto ficar dizendo \"como em Java\" e \"como em Python\", pois na verdade C veio antes de ambas! Enfim, mesmo com a ferrugem p\u00f3s-f\u00e9rias, voc\u00eas j\u00e1 devem ter percebido que essa fant\u00e1stica fun\u00e7\u00e3o faz... nada de \u00fatil. Ela apenas copia o valor do par\u00e2metro level para a vari\u00e1vel new_level e devolve o valor de new_level . Em outras palavras, apenas devolve o valor original de level , sem fazer nenhum tipo de processamento. Yay! Vejamos o contexto no qual essa fun\u00e7\u00e3o est\u00e1 sendo chamada. Note NEWPAGE???????????????????????????????????????????? #ifdef PARTE3 for ( int y = 0 ; y < IMG_HEIGHT ; y ++ ) { for ( int x = 0 ; x < IMG_HEIGHT ; x ++ ) { imgOut [ y ][ x ] = process_pixel ( imgIn [ y ][ x ]); } } #endif Hoje voc\u00eas n\u00e3o precisam saber todos os detalhes desse c\u00f3digo (isso acontecer\u00e1 na primeira aula de quarta), apenas que esses loops substituem o valor original de cada pixel da imagem pelo resultado devolvido por process_pixel , calculado a partir desse valor original. Como acabamos de ver que a fun\u00e7\u00e3o simplesmente devolve o mesmo valor, ent\u00e3o a imagem permanece inalterada. Vamos fazer algo mais interessante? Exerc\u00edcios Preliminares \u00b6 Para todos os exerc\u00edcios deste handout, sigam por favor as regras abaixo. Todos os enunciados dizem \"o que\" a fun\u00e7\u00e3o deve fazer, mas n\u00e3o dizem \"como\" ela deve fazer. Essa restri\u00e7\u00e3o \u00e9 proposital! N\u00e3o pergunte \"como\", pois descobrir isso \u00e9 justamente uma das habilidades que voc\u00eas precisam exercitar para as tr\u00eas disciplinas. Ao terminar um exerc\u00edcio, chame um dos professores para testemunhar o programa funcionando e validar o c\u00f3digo. N\u00e3o avance no guia at\u00e9 fazer isso, para termos certeza que voc\u00ea est\u00e1 passando por todo o processo. Question O valor de um pixel \u00e9 um n\u00famero inteiro entre 0 e 255 . Quanto mais alto o valor, mais claro \u00e9 o pixel. Sabendo disso, altere process_pixel para negativizar a imagem, ou seja, transformar pixels claros em escuros e vice-versa. Question Agora altere process_pixel para escurecer a imagem: cada pixel deve ficar com a metade de sua luminosidade original. Antes do pr\u00f3ximo exerc\u00edcio, uma dica! A sintaxe de if/else em C, para variar, \u00e9 como em Java. Ou seja: if ( condi\u00e7\u00e3o ) { instru\u00e7\u00e3o instru\u00e7\u00e3o ... } else { instru\u00e7\u00e3o instru\u00e7\u00e3o ... } Sabendo disso... Question Altere process_pixel para receber um segundo par\u00e2metro, tamb\u00e9m inteiro, e limiarizar a imagem: se o valor original do pixel for menor que esse segundo par\u00e2metro, seu novo valor deve ser 0 (preto); se o valor original do pixel for maior ou igual que esse segundo par\u00e2metro, seu novo valor deve ser 255 (branco). N\u00e3o esque\u00e7a de alterar o trecho de c\u00f3digo em que process_pixel \u00e9 chamada, para evitar erros de compila\u00e7\u00e3o. Passe 127 como o segundo par\u00e2metro da chamada. Question Altere process_pixel para manipular o brilho da imagem: use o segundo par\u00e2metro, adicionado no exerc\u00edcio anterior, como um valor que \u00e9 somado ao pixel. Fa\u00e7a v\u00e1rios testes, passando m\u00faltiplos valores como o segundo par\u00e2metro da chamada. Question Altere process_pixel para manipular o contraste da imagem: use o segundo par\u00e2metro como um valor que multiplica o pixel. Novamente, fa\u00e7a v\u00e1rios testes, passando m\u00faltiplos valores como o segundo par\u00e2metro da chamada. Nesses exerc\u00edcios preliminares, voc\u00eas j\u00e1 usaram os operadores aritm\u00e9ticos b\u00e1sicos ( + , - , / , * ), execu\u00e7\u00e3o condicional ( if/else ) e a estrutura b\u00e1sica de fun\u00e7\u00f5es. Agora vamos sair do Atmel! Exerc\u00edcios Intermedi\u00e1rios \u00b6 Ali\u00e1s, n\u00e3o apenas do Atmel... vamos sair do computador por alguns instantes e fazer os pr\u00f3ximos exerc\u00edcios no papel. \u00c9 muito importante que, pelo menos nesse come\u00e7o, voc\u00ea n\u00e3o fique excessivamente dependente do computador e da IDE. Saiba fazer pelo menos o b\u00e1sico sozinho, pois isso faz muita diferen\u00e7a na produtividade. Question Como esperado, a sintaxe de while em C tamb\u00e9m \u00e9 como em Java. Sabendo disso, considere o c\u00f3digo abaixo, que calcula a soma dos n\u00fameros de 1 a 10 . int s ; int i ; i = 0 ; while ( i < 10 ) { s += i ; i ++ ; } Ou melhor, que deveria calcular a soma dos n\u00fameros de 1 a 10 . Qual \u00e9 o problema com esse c\u00f3digo? Warning N\u00e3o continuem antes de validar suas respostas com um dos professores. Esse tipo de exerc\u00edcio ser\u00e1 avaliado ao longo do semestre. Note NEWPAGE???????????????????????????????????????????? Podemos identificar no c\u00f3digo os tr\u00eas problemas abaixo. A vari\u00e1vel s n\u00e3o \u00e9 inicializada. Em Java, o valor padr\u00e3o de uma vari\u00e1vel int \u00e9 0 , mas em C essa garantia n\u00e3o existe! De fato, uma vari\u00e1vel em C \u00e9 inicializada com lixo de mem\u00f3ria , ou seja, um valor baseado nos bits que j\u00e1 estavam escritos no peda\u00e7o de mem\u00f3ria que foi reservado para a vari\u00e1vel. Esses bits s\u00e3o totalmente imprevis\u00edveis! Se a condi\u00e7\u00e3o do while \u00e9 i < 10 , ent\u00e3o o \u00faltimo valor de i somado a s \u00e9 9 e n\u00e3o 10 . A soma est\u00e1 incompleta! A vari\u00e1vel i deveria ter sido inicializada com o valor 1 . A rigor, esse problema n\u00e3o torna o c\u00f3digo incorreto , pois a soma de 0 \u00e9 in\u00f3cua, mas torna o c\u00f3digo ineficiente , pois uma itera\u00e7\u00e3o \u00e9 desperdi\u00e7ada. Question Reescreva o c\u00f3digo, evitando os tr\u00eas problemas acima. Warning N\u00e3o continuem antes de validar suas respostas com um dos professores. Esse tipo de exerc\u00edcio ser\u00e1 avaliado ao longo do semestre. Note NEWPAGE???????????????????????????????????????????? Question Considere agora o c\u00f3digo abaixo, que deveria calcular a metade da soma dos n\u00fameros de 1 a 10 . int s = 0 ; int i ; i = 1 ; while ( i <= 10 ) { s += i / 2 ; i ++ ; } Qual \u00e9 o problema com esse c\u00f3digo? Warning N\u00e3o continuem antes de validar suas respostas com um dos professores. Esse tipo de exerc\u00edcio ser\u00e1 avaliado ao longo do semestre. Note NEWPAGE???????????????????????????????????????????? Quando os dois par\u00e2metros do operador / s\u00e3o inteiros, o resultado tamb\u00e9m \u00e9 um inteiro. Se a divis\u00e3o n\u00e3o for exata, a parte fracion\u00e1ria \u00e9 truncada . Isso significa que o que deveria ser a soma de 0.5 , 1 , 1.5 , 2 , 2.5 , etc. \u00e9 na verdade a soma de 0 , 1 , 1 , 2 , 2 , etc. Para resolver isso, precisamos primeiramente declarar s como double , permitindo a essa vari\u00e1vel representar n\u00fameros reais... adivinhem... como em Java. double s = 0 ; int i ; i = 1 ; while ( i <= 10 ) { s += i / 2 ; i ++ ; } Mas isso n\u00e3o \u00e9 suficiente! N\u00e3o adianta s poder armazenar reais se o que ela recebe de / s\u00e3o inteiros. Precisamos tamb\u00e9m garantir que / devolve um real, e isso acontece se pelo menos um dos dois n\u00fameros envolvidos na divis\u00e3o \u00e9 reconhecido como real. Existem duas maneiras simples de conseguir esse reconhecimento. O primeiro \u00e9 simplesmente substituir 2 por 2.0 . A exist\u00eancia de uma parte fracion\u00e1ria, mesmo sendo zero, simboliza que o n\u00famero \u00e9 real. double s = 0 ; int i ; i = 1 ; while ( i <= 10 ) { s += i / 2.0 ; i ++ ; } O segundo \u00e9 fazer um casting de i para double antes da divis\u00e3o. Lembram do conceito de casting? Significa pedir para o programa interpretar uma vari\u00e1vel como sendo de certo tipo. double s = 0 ; int i ; i = 1 ; while ( i <= 10 ) { s += ( double ) i / 2 ; i ++ ; } Note que um casting de int para double \u00e9 praticamente in\u00f3cuo, mas no casting de double para int perde-se a informa\u00e7\u00e3o fracion\u00e1ria.","title":"Lab 1 - Conceitos B\u00e1sicos"},{"location":"Lab1/#lab-1-conceitos-basicos","text":"Note Por favor, fa\u00e7am esta atividade em dupla . Note Esse laborat\u00f3rio deve ser realizado com a mesma infra do day-one: AtmelStudio, kit de desenvolvimento de embarcados e LCD.","title":"Lab 1 - Conceitos B\u00e1sicos"},{"location":"Lab1/#introducao","text":"N\u00e3o \u00e9 f\u00e1cil prever o quanto a linguagem C ser\u00e1 uma novidade para voc\u00eas. Por um lado, a sintaxe \u00e9 muito parecida com Java. Por outro lado, existem diferen\u00e7as importantes e voc\u00eas est\u00e3o longe de Java h\u00e1 mais ou menos meio semestre... Vamos come\u00e7ar com a revis\u00e3o de alguns conceitos bem b\u00e1sicos. Procure, mais ou menos na metade do arquivo main.c , a fun\u00e7\u00e3o process_pixel . int process_pixel ( int level ) { int new_level ; new_level = level ; return new_level ; } Essa fun\u00e7\u00e3o \u00e9 trivial, mas no c\u00f3digo j\u00e1 vemos v\u00e1rios conceitos importantes: as instru\u00e7\u00f5es terminam em ponto-e-v\u00edrgula, como em Java; new_level \u00e9 uma vari\u00e1vel da fun\u00e7\u00e3o e precisa ser declarada para poder ser usada, como em Java; valores e vari\u00e1veis possuem tipo , pois C \u00e9 uma linguagem com tipagem forte , como Java; a declara\u00e7\u00e3o de uma vari\u00e1vel segue a sintaxe tipo nome , como em Java; int \u00e9 o tipo que representa n\u00fameros inteiros, como em Java; como tipagem forte significa que tudo , sem exce\u00e7\u00e3o, tem tipo, int tamb\u00e9m aparece antes da declara\u00e7\u00e3o do par\u00e2metro level , indicando que esse par\u00e2metro \u00e9 um n\u00famero inteiro, e antes do pr\u00f3prio nome da fun\u00e7\u00e3o, indicando que process_pixel devolve um n\u00famero inteiro; essa devolu\u00e7\u00e3o, ali\u00e1s, \u00e9 feita atrav\u00e9s da instru\u00e7\u00e3o return , como em Python e Java; tamb\u00e9m em comum com Python e Java, temos o operador = de atribui\u00e7\u00e3o. Na verdade, soa um pouco injusto ficar dizendo \"como em Java\" e \"como em Python\", pois na verdade C veio antes de ambas! Enfim, mesmo com a ferrugem p\u00f3s-f\u00e9rias, voc\u00eas j\u00e1 devem ter percebido que essa fant\u00e1stica fun\u00e7\u00e3o faz... nada de \u00fatil. Ela apenas copia o valor do par\u00e2metro level para a vari\u00e1vel new_level e devolve o valor de new_level . Em outras palavras, apenas devolve o valor original de level , sem fazer nenhum tipo de processamento. Yay! Vejamos o contexto no qual essa fun\u00e7\u00e3o est\u00e1 sendo chamada. Note NEWPAGE???????????????????????????????????????????? #ifdef PARTE3 for ( int y = 0 ; y < IMG_HEIGHT ; y ++ ) { for ( int x = 0 ; x < IMG_HEIGHT ; x ++ ) { imgOut [ y ][ x ] = process_pixel ( imgIn [ y ][ x ]); } } #endif Hoje voc\u00eas n\u00e3o precisam saber todos os detalhes desse c\u00f3digo (isso acontecer\u00e1 na primeira aula de quarta), apenas que esses loops substituem o valor original de cada pixel da imagem pelo resultado devolvido por process_pixel , calculado a partir desse valor original. Como acabamos de ver que a fun\u00e7\u00e3o simplesmente devolve o mesmo valor, ent\u00e3o a imagem permanece inalterada. Vamos fazer algo mais interessante?","title":"Introdu\u00e7\u00e3o"},{"location":"Lab1/#exercicios-preliminares","text":"Para todos os exerc\u00edcios deste handout, sigam por favor as regras abaixo. Todos os enunciados dizem \"o que\" a fun\u00e7\u00e3o deve fazer, mas n\u00e3o dizem \"como\" ela deve fazer. Essa restri\u00e7\u00e3o \u00e9 proposital! N\u00e3o pergunte \"como\", pois descobrir isso \u00e9 justamente uma das habilidades que voc\u00eas precisam exercitar para as tr\u00eas disciplinas. Ao terminar um exerc\u00edcio, chame um dos professores para testemunhar o programa funcionando e validar o c\u00f3digo. N\u00e3o avance no guia at\u00e9 fazer isso, para termos certeza que voc\u00ea est\u00e1 passando por todo o processo. Question O valor de um pixel \u00e9 um n\u00famero inteiro entre 0 e 255 . Quanto mais alto o valor, mais claro \u00e9 o pixel. Sabendo disso, altere process_pixel para negativizar a imagem, ou seja, transformar pixels claros em escuros e vice-versa. Question Agora altere process_pixel para escurecer a imagem: cada pixel deve ficar com a metade de sua luminosidade original. Antes do pr\u00f3ximo exerc\u00edcio, uma dica! A sintaxe de if/else em C, para variar, \u00e9 como em Java. Ou seja: if ( condi\u00e7\u00e3o ) { instru\u00e7\u00e3o instru\u00e7\u00e3o ... } else { instru\u00e7\u00e3o instru\u00e7\u00e3o ... } Sabendo disso... Question Altere process_pixel para receber um segundo par\u00e2metro, tamb\u00e9m inteiro, e limiarizar a imagem: se o valor original do pixel for menor que esse segundo par\u00e2metro, seu novo valor deve ser 0 (preto); se o valor original do pixel for maior ou igual que esse segundo par\u00e2metro, seu novo valor deve ser 255 (branco). N\u00e3o esque\u00e7a de alterar o trecho de c\u00f3digo em que process_pixel \u00e9 chamada, para evitar erros de compila\u00e7\u00e3o. Passe 127 como o segundo par\u00e2metro da chamada. Question Altere process_pixel para manipular o brilho da imagem: use o segundo par\u00e2metro, adicionado no exerc\u00edcio anterior, como um valor que \u00e9 somado ao pixel. Fa\u00e7a v\u00e1rios testes, passando m\u00faltiplos valores como o segundo par\u00e2metro da chamada. Question Altere process_pixel para manipular o contraste da imagem: use o segundo par\u00e2metro como um valor que multiplica o pixel. Novamente, fa\u00e7a v\u00e1rios testes, passando m\u00faltiplos valores como o segundo par\u00e2metro da chamada. Nesses exerc\u00edcios preliminares, voc\u00eas j\u00e1 usaram os operadores aritm\u00e9ticos b\u00e1sicos ( + , - , / , * ), execu\u00e7\u00e3o condicional ( if/else ) e a estrutura b\u00e1sica de fun\u00e7\u00f5es. Agora vamos sair do Atmel!","title":"Exerc\u00edcios Preliminares"},{"location":"Lab1/#exercicios-intermediarios","text":"Ali\u00e1s, n\u00e3o apenas do Atmel... vamos sair do computador por alguns instantes e fazer os pr\u00f3ximos exerc\u00edcios no papel. \u00c9 muito importante que, pelo menos nesse come\u00e7o, voc\u00ea n\u00e3o fique excessivamente dependente do computador e da IDE. Saiba fazer pelo menos o b\u00e1sico sozinho, pois isso faz muita diferen\u00e7a na produtividade. Question Como esperado, a sintaxe de while em C tamb\u00e9m \u00e9 como em Java. Sabendo disso, considere o c\u00f3digo abaixo, que calcula a soma dos n\u00fameros de 1 a 10 . int s ; int i ; i = 0 ; while ( i < 10 ) { s += i ; i ++ ; } Ou melhor, que deveria calcular a soma dos n\u00fameros de 1 a 10 . Qual \u00e9 o problema com esse c\u00f3digo? Warning N\u00e3o continuem antes de validar suas respostas com um dos professores. Esse tipo de exerc\u00edcio ser\u00e1 avaliado ao longo do semestre. Note NEWPAGE???????????????????????????????????????????? Podemos identificar no c\u00f3digo os tr\u00eas problemas abaixo. A vari\u00e1vel s n\u00e3o \u00e9 inicializada. Em Java, o valor padr\u00e3o de uma vari\u00e1vel int \u00e9 0 , mas em C essa garantia n\u00e3o existe! De fato, uma vari\u00e1vel em C \u00e9 inicializada com lixo de mem\u00f3ria , ou seja, um valor baseado nos bits que j\u00e1 estavam escritos no peda\u00e7o de mem\u00f3ria que foi reservado para a vari\u00e1vel. Esses bits s\u00e3o totalmente imprevis\u00edveis! Se a condi\u00e7\u00e3o do while \u00e9 i < 10 , ent\u00e3o o \u00faltimo valor de i somado a s \u00e9 9 e n\u00e3o 10 . A soma est\u00e1 incompleta! A vari\u00e1vel i deveria ter sido inicializada com o valor 1 . A rigor, esse problema n\u00e3o torna o c\u00f3digo incorreto , pois a soma de 0 \u00e9 in\u00f3cua, mas torna o c\u00f3digo ineficiente , pois uma itera\u00e7\u00e3o \u00e9 desperdi\u00e7ada. Question Reescreva o c\u00f3digo, evitando os tr\u00eas problemas acima. Warning N\u00e3o continuem antes de validar suas respostas com um dos professores. Esse tipo de exerc\u00edcio ser\u00e1 avaliado ao longo do semestre. Note NEWPAGE???????????????????????????????????????????? Question Considere agora o c\u00f3digo abaixo, que deveria calcular a metade da soma dos n\u00fameros de 1 a 10 . int s = 0 ; int i ; i = 1 ; while ( i <= 10 ) { s += i / 2 ; i ++ ; } Qual \u00e9 o problema com esse c\u00f3digo? Warning N\u00e3o continuem antes de validar suas respostas com um dos professores. Esse tipo de exerc\u00edcio ser\u00e1 avaliado ao longo do semestre. Note NEWPAGE???????????????????????????????????????????? Quando os dois par\u00e2metros do operador / s\u00e3o inteiros, o resultado tamb\u00e9m \u00e9 um inteiro. Se a divis\u00e3o n\u00e3o for exata, a parte fracion\u00e1ria \u00e9 truncada . Isso significa que o que deveria ser a soma de 0.5 , 1 , 1.5 , 2 , 2.5 , etc. \u00e9 na verdade a soma de 0 , 1 , 1 , 2 , 2 , etc. Para resolver isso, precisamos primeiramente declarar s como double , permitindo a essa vari\u00e1vel representar n\u00fameros reais... adivinhem... como em Java. double s = 0 ; int i ; i = 1 ; while ( i <= 10 ) { s += i / 2 ; i ++ ; } Mas isso n\u00e3o \u00e9 suficiente! N\u00e3o adianta s poder armazenar reais se o que ela recebe de / s\u00e3o inteiros. Precisamos tamb\u00e9m garantir que / devolve um real, e isso acontece se pelo menos um dos dois n\u00fameros envolvidos na divis\u00e3o \u00e9 reconhecido como real. Existem duas maneiras simples de conseguir esse reconhecimento. O primeiro \u00e9 simplesmente substituir 2 por 2.0 . A exist\u00eancia de uma parte fracion\u00e1ria, mesmo sendo zero, simboliza que o n\u00famero \u00e9 real. double s = 0 ; int i ; i = 1 ; while ( i <= 10 ) { s += i / 2.0 ; i ++ ; } O segundo \u00e9 fazer um casting de i para double antes da divis\u00e3o. Lembram do conceito de casting? Significa pedir para o programa interpretar uma vari\u00e1vel como sendo de certo tipo. double s = 0 ; int i ; i = 1 ; while ( i <= 10 ) { s += ( double ) i / 2 ; i ++ ; } Note que um casting de int para double \u00e9 praticamente in\u00f3cuo, mas no casting de double para int perde-se a informa\u00e7\u00e3o fracion\u00e1ria.","title":"Exerc\u00edcios Intermedi\u00e1rios"},{"location":"Lab2/","text":"Lab 2 - Praticando \u00b6 Agora que praticamos um pouco no papel (de novo, habilidade fundamental para qualquer programador), vamos voltar ao computador, mas em um ambiente mais geral que o Atmel. Na verdade, o verdadeiro ambiente ser\u00e1 apresentado na leitura que passaremos para ter\u00e7a e na primeira aula de quarta, mas por enquanto vamos usar um mais simples, que n\u00e3o exige instala\u00e7\u00e3o. Entre no site https://www.onlinegdb.com/online_c_compiler . Como mencionado, esse ambiente \u00e9 muito simples: vamos apenas digitar o c\u00f3digo e rod\u00e1-lo atrav\u00e9s do bot\u00e3o verde \"Run\". Warning Nesse exerc\u00edcio n\u00e3o \u00e9 necess\u00e1rio esperar a valida\u00e7\u00e3o de um professor. Vamos come\u00e7ar analisando o c\u00f3digo que j\u00e1 vem pronto no ambiente. #include <stdio.h> int main () { printf ( \"Hello World\" ); return 0 ; } Novamente, temos um c\u00f3digo curto mas com v\u00e1rios conceitos importantes: a fun\u00e7\u00e3o main equivale ao m\u00e9todo main em Java, ou seja, \u00e9 a fun\u00e7\u00e3o principal , chamada quando o programa \u00e9 rodado; diferente de Java, no entanto, essa fun\u00e7\u00e3o \u00e9 int em vez de void , pois devolve um c\u00f3digo que indica se o programa foi bem-sucedido ou n\u00e3o; por enquanto, consideraremos apenas a devolu\u00e7\u00e3o do c\u00f3digo 0 , que indica que o programa foi, sim, bem-sucedido; #include equivale ao import em Python e Java, ou seja, amplia o conjunto de funcionalidades que o programa pode usar; de fato, \u00e9 justamente por causa do #include <stdio.h> que o programa pode usar a fun\u00e7\u00e3o printf . printf corresponde \u00e0 System.out.print em Java, ou seja, \u00e9 a fun\u00e7\u00e3o respons\u00e1vel por imprimir texto no terminal. No entanto, existe uma diferen\u00e7a de uso entre a printf do C e a System.out.print do Java. O c\u00f3digo abaixo n\u00e3o vai funcionar. #include <stdio.h> int main () { int n = 1 ; int m = 2 ; printf ( \"Hello World: \" + n + \", \" + m + \" \\n \" ); return 0 ; } A fun\u00e7\u00e3o printf usa um sistema de interpola\u00e7\u00e3o para exibir valores: #include <stdio.h> int main () { int n = 1 ; int m = 2 ; printf ( \"Hello World: %d, %d \\n \" , n , m ); return 0 ; } O c\u00f3digo acima significa \"substitua as duas ocorr\u00eancias de %d pelos valores de n e m , pela ordem\". Parece complicado, mas note que na verdade \u00e9 uma sintaxe mais limpa que a do Java, sem a necessidade de ficar somando strings. O s\u00edmbolo a ser substitu\u00eddo \u00e9 sempre % seguido de letras que representam o tipo do valor. A letra d (de \"decimal\") representa int , enquanto as letras lf (de \"long float\") representam double . #include <stdio.h> int main () { double n = 1 ; double m = 2 ; printf ( \"Hello World: %lf, %lf\" , n , m ); return 0 ; } Antes de apresentar outros conceitos, vamos praticar um pouco no ambiente. Question int s ; int i ; i = 0 ; while ( i < 10 ) { s += i ; i ++ ; } Esse c\u00f3digo errado j\u00e1 apareceu no laborat\u00f3rio anterior. Ele deveria calcular a soma de 1 a 10 . Rode o c\u00f3digo corrigido no ambiente online, e fa\u00e7a ele imprimir o resultado com printf() Question int s = 0 ; int i ; i = 1 ; while ( i <= 10 ) { s += i / 2 ; i ++ ; } Esse c\u00f3digo errado j\u00e1 apareceu no laborat\u00f3rio anterior. Ele deveria calcular a metade da soma dos n\u00famereos de 1 a 10 Rode o c\u00f3digo corrigido no ambiente online, e fa\u00e7a ele imprimir o resultado Vamos agora finalmente escrever um programa com intera\u00e7\u00e3o de usu\u00e1rio! #include <stdio.h> int main () { int n ; printf ( \"Digite um n\u00famero: \" ); scanf ( \"%d\" , & n ); printf ( \"O n\u00famero digitado \u00e9: %d \\n \" , n ); return 0 ; } Enquanto a fun\u00e7\u00e3o printf usa o s\u00edmbolo %d para indicar que quer \"escrever um inteiro\", a fun\u00e7\u00e3o scanf usa o s\u00edmbolo %d para indicar que quer \"ler um inteiro\". Note tamb\u00e9m uma diferen\u00e7a important\u00edssima entre printf e scanf : apenas no segundo h\u00e1 um & antes da vari\u00e1vel. Os detalhes t\u00e9cnicos disso ser\u00e3o revelados na segunda aula de quarta, mas por enquanto mantenha em mente que se voc\u00ea esquecer o & , o scanf n\u00e3o vai funcionar . Preparados para um exemplo mais avan\u00e7ado? O pr\u00f3ximo mostra de uma s\u00f3 vez: inclus\u00e3o de outra biblioteca al\u00e9m de stdio.h ; defini\u00e7\u00e3o de uma constante; implementa\u00e7\u00e3o e chamada de uma fun\u00e7\u00e3o pr\u00f3pria. Note NEWPAGE???????????????????????????????????????????? #include <stdio.h> #include <math.h> #define PI 3.141592 void print_trigo ( int a ) { printf ( \"seno: %lf, cosseno: %lf \\n \" , sin ( a ), cos ( a )); } int main () { int angle ; printf ( \"Digite um \u00e2ngulo em graus: \" ); scanf ( \"%d\" , & angle ); print_trigo ( angle ); return 0 ; } Vejamos o que h\u00e1 de novo no c\u00f3digo: adicionamos #include <math.h> e, por causa disso, pudemos usar as fun\u00e7\u00f5es trigonom\u00e9tricas sin e cos para calcular seno e cosseno respectivamente; definimos a constante PI como sendo o real 3.141592 ; implementamos e chamamos a fun\u00e7\u00e3o print_trigo , que n\u00e3o precisa de return por ser do tipo void ; A diferen\u00e7a entre vari\u00e1veis e constantes \u00e9 que, enquanto uma vari\u00e1vel \u00e9... er... vari\u00e1vel, uma constante \u00e9... er... constante, ou seja, n\u00e3o pode ser alterada: o c\u00f3digo PI = 5 causaria um erro. Por falar em PI , reparou que definimos a constante mas nunca a usamos? Na verdade, n\u00e3o foi um acidente... Question Qual \u00e9 o problema no c\u00f3digo acima? A dica j\u00e1 est\u00e1 dada: para ser resolvido, precisamos usar PI ... Question Resolva o problema! Warning N\u00e3o continue antes de validar suas respostas com um dos professores. Esse tipo de exerc\u00edcio ser\u00e1 avaliado ao longo do semestre. Exerc\u00edcios Avan\u00e7ados \u00b6 Mesmo que n\u00e3o d\u00ea tempo de fazer esses exerc\u00edcios em sala, \u00e9 muito importante que voc\u00ea os fa\u00e7a at\u00e9 quarta para desenferrujar programa\u00e7\u00e3o e praticar C. Question Escreva uma fun\u00e7\u00e3o que recebe um inteiro e devolve o m\u00f3dulo desse inteiro. Question Escreva uma fun\u00e7\u00e3o que recebe quatro inteiros, representando as coordenadas de dois pontos no plano cartesiano, e devolve a dist\u00e2ncia de Manhattan (pesquise) entre esses pontos. Voc\u00eas j\u00e1 fiazeram esse exerc\u00edcio em Desenvolvimento Colaborativo \u00c1gil . Question Escreva uma fun\u00e7\u00e3o que recebe um inteiro n e, para cada inteiro i entre 1 e n , imprime uma string conforme a seguinte regra: \"nenhum\" se i n\u00e3o for m\u00faltiplo de 3 nem 5 ; \"apenas por tr\u00eas\" se i for m\u00faltiplo de 3 mas n\u00e3o de 5 ; \"apenas por cinco\" se i for m\u00faltiplo de 5 mas n\u00e3o de 3 ; \"por tr\u00eas e por cinco\" se i for m\u00faltiplo de 3 e 5 . Escreva duas vers\u00f5es: uma usando while s e outra usando for s. Question Escreva uma fun\u00e7\u00e3o que recebe um inteiro n e imprime uma \"arvorezinha\" conforme a regra abaixo. n = 1 | n = 2 | /|\\ n = 3 | /|\\ //|\\\\ e assim em diante para n = 4, 5, 6... . Ap\u00eandice \u00b6 O for n\u00e3o foi abordado neste guia, mas ser\u00e1 usado nas pr\u00f3ximas aulas. Assim como o for padr\u00e3o do Java, o for do C n\u00e3o funciona como o for do Python. Na verdade, \u00e9 apenas um \"a\u00e7\u00facar sint\u00e1tico\" que facilita a escrita de loops: for ( i = 0 ; i < 10 ; i ++ ) { instru\u00e7\u00e3o instru\u00e7\u00e3o ... } equivale a i = 0 ; while ( i < 10 ) { instru\u00e7\u00e3o instru\u00e7\u00e3o ... i ++ ; } Em Java existe o enhanced for , que \u00e9 mais parecido com o for do Python, mas n\u00e3o existe uma equival\u00eancia disso em C. Bem-vindos ao baixo n\u00edvel! N\u00e3o temos bolo, mas temos os ingredientes para voc\u00ea fazer um bolo.","title":"Lab 2 - Praticando"},{"location":"Lab2/#lab-2-praticando","text":"Agora que praticamos um pouco no papel (de novo, habilidade fundamental para qualquer programador), vamos voltar ao computador, mas em um ambiente mais geral que o Atmel. Na verdade, o verdadeiro ambiente ser\u00e1 apresentado na leitura que passaremos para ter\u00e7a e na primeira aula de quarta, mas por enquanto vamos usar um mais simples, que n\u00e3o exige instala\u00e7\u00e3o. Entre no site https://www.onlinegdb.com/online_c_compiler . Como mencionado, esse ambiente \u00e9 muito simples: vamos apenas digitar o c\u00f3digo e rod\u00e1-lo atrav\u00e9s do bot\u00e3o verde \"Run\". Warning Nesse exerc\u00edcio n\u00e3o \u00e9 necess\u00e1rio esperar a valida\u00e7\u00e3o de um professor. Vamos come\u00e7ar analisando o c\u00f3digo que j\u00e1 vem pronto no ambiente. #include <stdio.h> int main () { printf ( \"Hello World\" ); return 0 ; } Novamente, temos um c\u00f3digo curto mas com v\u00e1rios conceitos importantes: a fun\u00e7\u00e3o main equivale ao m\u00e9todo main em Java, ou seja, \u00e9 a fun\u00e7\u00e3o principal , chamada quando o programa \u00e9 rodado; diferente de Java, no entanto, essa fun\u00e7\u00e3o \u00e9 int em vez de void , pois devolve um c\u00f3digo que indica se o programa foi bem-sucedido ou n\u00e3o; por enquanto, consideraremos apenas a devolu\u00e7\u00e3o do c\u00f3digo 0 , que indica que o programa foi, sim, bem-sucedido; #include equivale ao import em Python e Java, ou seja, amplia o conjunto de funcionalidades que o programa pode usar; de fato, \u00e9 justamente por causa do #include <stdio.h> que o programa pode usar a fun\u00e7\u00e3o printf . printf corresponde \u00e0 System.out.print em Java, ou seja, \u00e9 a fun\u00e7\u00e3o respons\u00e1vel por imprimir texto no terminal. No entanto, existe uma diferen\u00e7a de uso entre a printf do C e a System.out.print do Java. O c\u00f3digo abaixo n\u00e3o vai funcionar. #include <stdio.h> int main () { int n = 1 ; int m = 2 ; printf ( \"Hello World: \" + n + \", \" + m + \" \\n \" ); return 0 ; } A fun\u00e7\u00e3o printf usa um sistema de interpola\u00e7\u00e3o para exibir valores: #include <stdio.h> int main () { int n = 1 ; int m = 2 ; printf ( \"Hello World: %d, %d \\n \" , n , m ); return 0 ; } O c\u00f3digo acima significa \"substitua as duas ocorr\u00eancias de %d pelos valores de n e m , pela ordem\". Parece complicado, mas note que na verdade \u00e9 uma sintaxe mais limpa que a do Java, sem a necessidade de ficar somando strings. O s\u00edmbolo a ser substitu\u00eddo \u00e9 sempre % seguido de letras que representam o tipo do valor. A letra d (de \"decimal\") representa int , enquanto as letras lf (de \"long float\") representam double . #include <stdio.h> int main () { double n = 1 ; double m = 2 ; printf ( \"Hello World: %lf, %lf\" , n , m ); return 0 ; } Antes de apresentar outros conceitos, vamos praticar um pouco no ambiente. Question int s ; int i ; i = 0 ; while ( i < 10 ) { s += i ; i ++ ; } Esse c\u00f3digo errado j\u00e1 apareceu no laborat\u00f3rio anterior. Ele deveria calcular a soma de 1 a 10 . Rode o c\u00f3digo corrigido no ambiente online, e fa\u00e7a ele imprimir o resultado com printf() Question int s = 0 ; int i ; i = 1 ; while ( i <= 10 ) { s += i / 2 ; i ++ ; } Esse c\u00f3digo errado j\u00e1 apareceu no laborat\u00f3rio anterior. Ele deveria calcular a metade da soma dos n\u00famereos de 1 a 10 Rode o c\u00f3digo corrigido no ambiente online, e fa\u00e7a ele imprimir o resultado Vamos agora finalmente escrever um programa com intera\u00e7\u00e3o de usu\u00e1rio! #include <stdio.h> int main () { int n ; printf ( \"Digite um n\u00famero: \" ); scanf ( \"%d\" , & n ); printf ( \"O n\u00famero digitado \u00e9: %d \\n \" , n ); return 0 ; } Enquanto a fun\u00e7\u00e3o printf usa o s\u00edmbolo %d para indicar que quer \"escrever um inteiro\", a fun\u00e7\u00e3o scanf usa o s\u00edmbolo %d para indicar que quer \"ler um inteiro\". Note tamb\u00e9m uma diferen\u00e7a important\u00edssima entre printf e scanf : apenas no segundo h\u00e1 um & antes da vari\u00e1vel. Os detalhes t\u00e9cnicos disso ser\u00e3o revelados na segunda aula de quarta, mas por enquanto mantenha em mente que se voc\u00ea esquecer o & , o scanf n\u00e3o vai funcionar . Preparados para um exemplo mais avan\u00e7ado? O pr\u00f3ximo mostra de uma s\u00f3 vez: inclus\u00e3o de outra biblioteca al\u00e9m de stdio.h ; defini\u00e7\u00e3o de uma constante; implementa\u00e7\u00e3o e chamada de uma fun\u00e7\u00e3o pr\u00f3pria. Note NEWPAGE???????????????????????????????????????????? #include <stdio.h> #include <math.h> #define PI 3.141592 void print_trigo ( int a ) { printf ( \"seno: %lf, cosseno: %lf \\n \" , sin ( a ), cos ( a )); } int main () { int angle ; printf ( \"Digite um \u00e2ngulo em graus: \" ); scanf ( \"%d\" , & angle ); print_trigo ( angle ); return 0 ; } Vejamos o que h\u00e1 de novo no c\u00f3digo: adicionamos #include <math.h> e, por causa disso, pudemos usar as fun\u00e7\u00f5es trigonom\u00e9tricas sin e cos para calcular seno e cosseno respectivamente; definimos a constante PI como sendo o real 3.141592 ; implementamos e chamamos a fun\u00e7\u00e3o print_trigo , que n\u00e3o precisa de return por ser do tipo void ; A diferen\u00e7a entre vari\u00e1veis e constantes \u00e9 que, enquanto uma vari\u00e1vel \u00e9... er... vari\u00e1vel, uma constante \u00e9... er... constante, ou seja, n\u00e3o pode ser alterada: o c\u00f3digo PI = 5 causaria um erro. Por falar em PI , reparou que definimos a constante mas nunca a usamos? Na verdade, n\u00e3o foi um acidente... Question Qual \u00e9 o problema no c\u00f3digo acima? A dica j\u00e1 est\u00e1 dada: para ser resolvido, precisamos usar PI ... Question Resolva o problema! Warning N\u00e3o continue antes de validar suas respostas com um dos professores. Esse tipo de exerc\u00edcio ser\u00e1 avaliado ao longo do semestre.","title":"Lab 2 - Praticando"},{"location":"Lab2/#exercicios-avancados","text":"Mesmo que n\u00e3o d\u00ea tempo de fazer esses exerc\u00edcios em sala, \u00e9 muito importante que voc\u00ea os fa\u00e7a at\u00e9 quarta para desenferrujar programa\u00e7\u00e3o e praticar C. Question Escreva uma fun\u00e7\u00e3o que recebe um inteiro e devolve o m\u00f3dulo desse inteiro. Question Escreva uma fun\u00e7\u00e3o que recebe quatro inteiros, representando as coordenadas de dois pontos no plano cartesiano, e devolve a dist\u00e2ncia de Manhattan (pesquise) entre esses pontos. Voc\u00eas j\u00e1 fiazeram esse exerc\u00edcio em Desenvolvimento Colaborativo \u00c1gil . Question Escreva uma fun\u00e7\u00e3o que recebe um inteiro n e, para cada inteiro i entre 1 e n , imprime uma string conforme a seguinte regra: \"nenhum\" se i n\u00e3o for m\u00faltiplo de 3 nem 5 ; \"apenas por tr\u00eas\" se i for m\u00faltiplo de 3 mas n\u00e3o de 5 ; \"apenas por cinco\" se i for m\u00faltiplo de 5 mas n\u00e3o de 3 ; \"por tr\u00eas e por cinco\" se i for m\u00faltiplo de 3 e 5 . Escreva duas vers\u00f5es: uma usando while s e outra usando for s. Question Escreva uma fun\u00e7\u00e3o que recebe um inteiro n e imprime uma \"arvorezinha\" conforme a regra abaixo. n = 1 | n = 2 | /|\\ n = 3 | /|\\ //|\\\\ e assim em diante para n = 4, 5, 6... .","title":"Exerc\u00edcios Avan\u00e7ados"},{"location":"Lab2/#apendice","text":"O for n\u00e3o foi abordado neste guia, mas ser\u00e1 usado nas pr\u00f3ximas aulas. Assim como o for padr\u00e3o do Java, o for do C n\u00e3o funciona como o for do Python. Na verdade, \u00e9 apenas um \"a\u00e7\u00facar sint\u00e1tico\" que facilita a escrita de loops: for ( i = 0 ; i < 10 ; i ++ ) { instru\u00e7\u00e3o instru\u00e7\u00e3o ... } equivale a i = 0 ; while ( i < 10 ) { instru\u00e7\u00e3o instru\u00e7\u00e3o ... i ++ ; } Em Java existe o enhanced for , que \u00e9 mais parecido com o for do Python, mas n\u00e3o existe uma equival\u00eancia disso em C. Bem-vindos ao baixo n\u00edvel! N\u00e3o temos bolo, mas temos os ingredientes para voc\u00ea fazer um bolo.","title":"Ap\u00eandice"},{"location":"Lab3/","text":"Lab 3 - Compila\u00e7\u00e3o usando GCC \u00b6 Ontem fizemos atividades usando um compilador online. Apesar de ser pr\u00e1tico, o ambiente online \u00e9 muito limitado e n\u00e3o \u00e9 adequado para as atividades do 5 semestre. Esta leitura visa familiariz\u00e1-lo com as ferramentas de compila\u00e7\u00e3o de c\u00f3digo em C usando o compilador gcc . O ambiente recomendado para a atividade \u00e9 o Ubuntu 18.04 LTS . Outras configura\u00e7\u00f5es s\u00e3o poss\u00edveis, mas n\u00e3o daremos suporte a elas. Tip Memorizar os comandos usados \u00e9 muito mais f\u00e1cil de voc\u00ea digit\u00e1-los no terminal ao inv\u00e9s de copiar e colar. Instala\u00e7\u00e3o local das ferramentas dos cursos \u00b6 As ferramentas que precisamos para o mutir\u00e3o est\u00e3o dispon\u00edveis nos pacotes build-essential e gdb . Os pacotes valgrind e kcachegrind ser\u00e3o usados mais para a frente e j\u00e1 podem ser instalados tamb\u00e9m. $ sudo apt install build-essential gdb valgrind kcachegrind Verifique que tudo funcionou rodando o seguinte comando $ gcc --version Se voc\u00ea recebeu uma mensagem indicando que est\u00e1 usando a vers\u00e3o 7.4 ent\u00e3o tudo est\u00e1 funcionando corretamente. gcc-7 (Ubuntu 7.4.0-29ubuntu1) 7.3.0 Copyright (C) 2017 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE Warning Esta padroniza\u00e7\u00e3o \u00e9 importante para evitar dores de cabe\u00e7a com comportamentos espec\u00edficos de uma certa vers\u00e3o. Assim como o restante do ambiente, \u00e9 poss\u00edvel que tudo funcine igual com outras vers\u00f5es do gcc . Por\u00e9m, n\u00e3o daremos suporte a ambientes diferentes do padronizado neste lab. Praticamente qualquer editor de texto ou IDE suporta coloriza\u00e7\u00e3o para C , por\u00e9m recomendamos utilizar alguma ferramenta que tamb\u00e9m corrija erros de sintaxe. Editores como Visual Studio Code (com plugin para C/C++ e Make) e Eclipse CDT s\u00e3o boas escolhas por serem multi-plataforma e suficientemente completos. Eles tamb\u00e9m ajudar\u00e3o muito no come\u00e7o por indicarem erros simples de sintaxe como esquecer de um ; ou usar scanf sem o & . Ap\u00f3s o mutir\u00e3o as atividades de Computa\u00e7\u00e3o Embarcada ser\u00e3o feitas em Windows usando Atmel Studio. Desafios de programa\u00e7\u00e3o e Sistemas de Hardware e Software continuar\u00e3o usando Ubuntu Linux. O qu\u00ea \u00e9 \"compilar\" um c\u00f3digo \u00b6 Diferente de Python, em que podemos rodar diretamente o script, ou Java, em que criamos um arquivo bin\u00e1rio multi-plataforma, programas em C precisam ser convertidos em instru\u00e7\u00f5es nativas do processador para serem executados. Chamamos esse processo que transforma c\u00f3digo em instru\u00e7\u00f5es execut\u00e1veis por uma CPU (f\u00edsica ou virtual) de compila\u00e7\u00e3o . O resultado final da compila\u00e7\u00e3o de um programa em C \u00e9 um arquivo execut\u00e1vel espec\u00edfico para uma arquitetura de CPU e Sistema Operacional. Veremos mais detalhes de como essa transforma\u00e7\u00e3o para c\u00f3digo de m\u00e1quina ocorre em Sistemas Hardware-Software. Compila\u00e7\u00e3o (simples) via linha de comando \u00b6 Usamos o comando gcc para compilar programas em C . Para diminuir a quantidade de erros nos programas podemos passar como argumento algumas flags para exibir erros comuns e para fazer somente otimiza\u00e7\u00f5es que n\u00e3o atrapalhem debug ( -Og ). $ gcc -Wall -pedantic -std = gnu99 -Og -o executavel arquivo.c -Wall : habilita todos avisos do compilador. Este modo indica poss\u00edveis erros cometidos no programa. -pedantic : modo de compila\u00e7\u00e3o mais estrito e mostra ainda mais avisos -std=gnu99 : vers\u00e3o da linguagem C usada ( C99 ) mais extens\u00f5es para sistemas POSIX GNU (veremos o qu\u00ea isto significa mais para frente). -Og : somente aplicar otimiza\u00e7\u00f5es que n\u00e3o atrapalham debuging . -o : output -- nome do execut\u00e1vel gerado Usando este comando podemos compilar um programa definido em um \u00fanico arquivo .c . Example Compile o arquivo printf.c usando o gcc e nomeie o execut\u00e1vel exemplo0 . Rode ele e verifique que tudo continua funcionando. Example Crie um programa que l\u00ea dois inteiros do terminal e determina se o primeiro \u00e9 m\u00faltiplo do segundo. Se o segundo n\u00famero passado for 0 seu programa dever\u00e1 mostrar uma mensagem de erro. Example Adapte seu programa acima para que ele receba v\u00e1rios pares de n\u00fameros e s\u00f3 pare de ser executado quando receber o par \"0 0\". Facilitando o uso da entrada e sa\u00edda padr\u00e3o \u00b6 Para interagir com nossos programas precisamos digitar valores e strings no terminal. Isto se torna chato e repetitivo bem r\u00e1pido. Para facilitar podemos utilizar o recurso de redirecionamento de entrada do terminal. Veja o exemplo abaixo. $ ./prog < arquivo_entrada.txt O programa prog ser\u00e1 executado como se o conte\u00fado do arquivo arquivo_entrada.txt tivesse sido digitado no terminal. Assim, podemos testar facilmente programas como o criado na Tarefa 3 acima sem precisar digitar sempre a mesma entrada. Example Crie um arquivo de entrada para o programa da tarefa 3 e verifique que o resultado do programa \u00e9 o mesmo que quando voc\u00ea digita manualmente os valores no terminal. Example O mesmo vale para a sa\u00edda, mas usando o caractere > . Capture a sa\u00edda do programa da tarefa 3 para um arquivo de nome saida3.txt . Example Podemos combinar o redirecionamento de entrada e sa\u00edda no mesmo comando. Teste esta funcionalidade usando o programa da tarefa 3.","title":"Lab 3 - Compila\u00e7\u00e3o usando GCC"},{"location":"Lab3/#lab-3-compilacao-usando-gcc","text":"Ontem fizemos atividades usando um compilador online. Apesar de ser pr\u00e1tico, o ambiente online \u00e9 muito limitado e n\u00e3o \u00e9 adequado para as atividades do 5 semestre. Esta leitura visa familiariz\u00e1-lo com as ferramentas de compila\u00e7\u00e3o de c\u00f3digo em C usando o compilador gcc . O ambiente recomendado para a atividade \u00e9 o Ubuntu 18.04 LTS . Outras configura\u00e7\u00f5es s\u00e3o poss\u00edveis, mas n\u00e3o daremos suporte a elas. Tip Memorizar os comandos usados \u00e9 muito mais f\u00e1cil de voc\u00ea digit\u00e1-los no terminal ao inv\u00e9s de copiar e colar.","title":"Lab 3 - Compila\u00e7\u00e3o usando GCC"},{"location":"Lab3/#instalacao-local-das-ferramentas-dos-cursos","text":"As ferramentas que precisamos para o mutir\u00e3o est\u00e3o dispon\u00edveis nos pacotes build-essential e gdb . Os pacotes valgrind e kcachegrind ser\u00e3o usados mais para a frente e j\u00e1 podem ser instalados tamb\u00e9m. $ sudo apt install build-essential gdb valgrind kcachegrind Verifique que tudo funcionou rodando o seguinte comando $ gcc --version Se voc\u00ea recebeu uma mensagem indicando que est\u00e1 usando a vers\u00e3o 7.4 ent\u00e3o tudo est\u00e1 funcionando corretamente. gcc-7 (Ubuntu 7.4.0-29ubuntu1) 7.3.0 Copyright (C) 2017 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE Warning Esta padroniza\u00e7\u00e3o \u00e9 importante para evitar dores de cabe\u00e7a com comportamentos espec\u00edficos de uma certa vers\u00e3o. Assim como o restante do ambiente, \u00e9 poss\u00edvel que tudo funcine igual com outras vers\u00f5es do gcc . Por\u00e9m, n\u00e3o daremos suporte a ambientes diferentes do padronizado neste lab. Praticamente qualquer editor de texto ou IDE suporta coloriza\u00e7\u00e3o para C , por\u00e9m recomendamos utilizar alguma ferramenta que tamb\u00e9m corrija erros de sintaxe. Editores como Visual Studio Code (com plugin para C/C++ e Make) e Eclipse CDT s\u00e3o boas escolhas por serem multi-plataforma e suficientemente completos. Eles tamb\u00e9m ajudar\u00e3o muito no come\u00e7o por indicarem erros simples de sintaxe como esquecer de um ; ou usar scanf sem o & . Ap\u00f3s o mutir\u00e3o as atividades de Computa\u00e7\u00e3o Embarcada ser\u00e3o feitas em Windows usando Atmel Studio. Desafios de programa\u00e7\u00e3o e Sistemas de Hardware e Software continuar\u00e3o usando Ubuntu Linux.","title":"Instala\u00e7\u00e3o local das ferramentas dos cursos"},{"location":"Lab3/#o-que-e-compilar-um-codigo","text":"Diferente de Python, em que podemos rodar diretamente o script, ou Java, em que criamos um arquivo bin\u00e1rio multi-plataforma, programas em C precisam ser convertidos em instru\u00e7\u00f5es nativas do processador para serem executados. Chamamos esse processo que transforma c\u00f3digo em instru\u00e7\u00f5es execut\u00e1veis por uma CPU (f\u00edsica ou virtual) de compila\u00e7\u00e3o . O resultado final da compila\u00e7\u00e3o de um programa em C \u00e9 um arquivo execut\u00e1vel espec\u00edfico para uma arquitetura de CPU e Sistema Operacional. Veremos mais detalhes de como essa transforma\u00e7\u00e3o para c\u00f3digo de m\u00e1quina ocorre em Sistemas Hardware-Software.","title":"O qu\u00ea \u00e9 \"compilar\" um c\u00f3digo"},{"location":"Lab3/#compilacao-simples-via-linha-de-comando","text":"Usamos o comando gcc para compilar programas em C . Para diminuir a quantidade de erros nos programas podemos passar como argumento algumas flags para exibir erros comuns e para fazer somente otimiza\u00e7\u00f5es que n\u00e3o atrapalhem debug ( -Og ). $ gcc -Wall -pedantic -std = gnu99 -Og -o executavel arquivo.c -Wall : habilita todos avisos do compilador. Este modo indica poss\u00edveis erros cometidos no programa. -pedantic : modo de compila\u00e7\u00e3o mais estrito e mostra ainda mais avisos -std=gnu99 : vers\u00e3o da linguagem C usada ( C99 ) mais extens\u00f5es para sistemas POSIX GNU (veremos o qu\u00ea isto significa mais para frente). -Og : somente aplicar otimiza\u00e7\u00f5es que n\u00e3o atrapalham debuging . -o : output -- nome do execut\u00e1vel gerado Usando este comando podemos compilar um programa definido em um \u00fanico arquivo .c . Example Compile o arquivo printf.c usando o gcc e nomeie o execut\u00e1vel exemplo0 . Rode ele e verifique que tudo continua funcionando. Example Crie um programa que l\u00ea dois inteiros do terminal e determina se o primeiro \u00e9 m\u00faltiplo do segundo. Se o segundo n\u00famero passado for 0 seu programa dever\u00e1 mostrar uma mensagem de erro. Example Adapte seu programa acima para que ele receba v\u00e1rios pares de n\u00fameros e s\u00f3 pare de ser executado quando receber o par \"0 0\".","title":"Compila\u00e7\u00e3o (simples) via linha de comando"},{"location":"Lab3/#facilitando-o-uso-da-entrada-e-saida-padrao","text":"Para interagir com nossos programas precisamos digitar valores e strings no terminal. Isto se torna chato e repetitivo bem r\u00e1pido. Para facilitar podemos utilizar o recurso de redirecionamento de entrada do terminal. Veja o exemplo abaixo. $ ./prog < arquivo_entrada.txt O programa prog ser\u00e1 executado como se o conte\u00fado do arquivo arquivo_entrada.txt tivesse sido digitado no terminal. Assim, podemos testar facilmente programas como o criado na Tarefa 3 acima sem precisar digitar sempre a mesma entrada. Example Crie um arquivo de entrada para o programa da tarefa 3 e verifique que o resultado do programa \u00e9 o mesmo que quando voc\u00ea digita manualmente os valores no terminal. Example O mesmo vale para a sa\u00edda, mas usando o caractere > . Capture a sa\u00edda do programa da tarefa 3 para um arquivo de nome saida3.txt . Example Podemos combinar o redirecionamento de entrada e sa\u00edda no mesmo comando. Teste esta funcionalidade usando o programa da tarefa 3.","title":"Facilitando o uso da entrada e sa\u00edda padr\u00e3o"},{"location":"Lab4/","text":"Lab 4 - Organiza\u00e7\u00e3o de dados \u00b6 Na \u00faltima aula trabalhamos com conceitos b\u00e1sicos de C e com tipos de dados simples (inteiros e n\u00fameros fracion\u00e1rios). Hoje veremos as primeiras estruturas complexas em C : vetores, matrizes e strings. Introdu\u00e7\u00e3o \u00b6 Criamos vetores de tamanho fixo em C usando a seguinte sintaxe: long vetor [ 100 ]; Basta adicionar [] ap\u00f3s o tipo e teremos um vetor de tamanho constante (i.e. n\u00e3o dependente da entrada do usu\u00e1rio). N\u00e3o \u00e9 poss\u00edvel redimensionar o vetor . Depois de declarado ele ter\u00e1 para sempre o mesmo tamanho. O acesso a elementos tamb\u00e9m \u00e9 bastante simples: printf ( \"%ld \\n \" , vetor [ 0 ]); A linha acima imprime o primeira valor do vetor. O uso com scanf segue a mesma l\u00f3gica dos tipos simples: scanf ( \"%ld\" , & vetor [ 0 ]); Tarefa 1 O c\u00f3digo abaixo compila? Se sim, qual \u00e9 sua sa\u00edda? Tarefa 2 O c\u00f3digo acima est\u00e1 no arquivo exemplos/erro_comum1.c . Compile e execute ele. Os resultados foram os esperados? Se n\u00e3o, voc\u00ea consegue explicar o por que eles foram diferentes? Como podemos ver, o c\u00f3digo compila, mas seu comportamento \u00e9 indefinido por duas raz\u00f5es: O vetor n\u00e3o \u00e9 inicializado com 0 quando \u00e9 criado. A posi\u00e7\u00e3o vetor[5] n\u00e3o \u00e9 v\u00e1lida e pode resultar na leitura de dados inv\u00e1lidos da mem\u00f3ria. Tip Diferentemente de outras linguagens, C n\u00e3o verifica os \u00edndices automaticamente nem inicializa o elementos do vetor com 0. Al\u00e9m disto, n\u00e3o \u00e9 poss\u00edvel obter o tamanho de um vetor a partir de seu nome. Um ponto importante \u00e9 que o sistema de tipos n\u00e3o permite a convers\u00e3o/passagem de vetores do mesmo tipo mas de tamanhos diferentes. Assim, a fun\u00e7\u00e3o abaixo n\u00e3o aceitaria como argumento a vari\u00e1vel double arr[4] , pois s\u00f3 aceita vetores de tamanho 3. double soma ( double arr [ 3 ]) { double s = 0 ; for ( int i = 0 ; i < 3 ; i ++ ) { s += arr [ i ]; } return s ; } Para faz\u00ea-la aceitar vetores de tamanho qualquer poder\u00edamos mudar sua assinatura para n\u00e3o checar o tamanho do vetor e pass\u00e1-lo como argumento da fun\u00e7\u00e3o. double soma ( double arr [], int n ); Tarefa 3 Modifique a fun\u00e7\u00e3o soma acima para aceitar vetores de qualquer tamanho. Lembre-se que arrays em C n\u00e3o conhecem seu tamanho, ent\u00e3o \u00e9 de sua responsabilidade acessar somente elementos v\u00e1lidos e checar se o vetor n\u00e3o est\u00e1 vazio (ou seja, n < 1 ) \\vspace{15em} !!! example \"Tarefa 4**: Vamos agora juntar vetores com a aula passada e com a leitura de ontem: escreva do zero um programa que Leia um inteiro n do terminal (n\u00famero de elementos do vetor) Leia n n\u00fameros fracion\u00e1rios e guard\u00e1-los em um array. Chame uma fun\u00e7\u00e3o para calcular a m\u00e9dia do vetor. Imprima a m\u00e9dia calculada. Seu programa dever\u00e1 calcular a m\u00e9dia usando uma fun\u00e7\u00e3o avg escrita por voc\u00ea mesmo e pode supor que n < 100 . Para facilitar seus testes, escreva dois arquivos de entrada e use < para rodar o programa. Tarefa 5 Modifique seu programa acima para que ele imprima tamb\u00e9m a vari\u00e2ncia do vetor. Strings \u00b6 Como visto na expositiva, strings s\u00e3o vetores de caracteres sendo que o \u00faltimo elemento da string cont\u00e9m um caractere '\\0' . Logo, uma string declarada como char str[100] pode guardar strings de at\u00e9 99 caracteres (mais 1 para o '\\0' ). Se a string tiver comprimento menor o restante das posi\u00e7\u00f5es simplesmente n\u00e3o \u00e9 utilizado. !!! example \"Tarefa 6**: Em Python n\u00e3o existe diferen\u00e7a entre \"a\" e 'a' . Isto \u00e9 verdade em C ? \\vspace{5em} Tarefa 7 Um aluno fez a seguinte fun\u00e7\u00e3o para c\u00f3pia de strings. void copia_string ( char str1 [], char str2 []) { int i = 0 ; while ( str1 [ i ] != '\\0' ) { str2 [ i ] = str1 [ i ]; i ++ ; } } Existem pelo menos dois problemas graves neste c\u00f3digo. Voc\u00ea consegue identific\u00e1-los? \\vspace{8em} Tarefa 8 Escreva abaixo uma fun\u00e7\u00e3o que recebe uma string como par\u00e2metro e retorne quantas vezes o caractere 1 aparece. \\vspace{15em} Tarefa 9 Escreva abaixo uma fun\u00e7\u00e3o que recebe uma string como par\u00e2metro e retorna 1 se ela \u00e9 um pal\u00edndromo ou 0 caso contr\u00e1rio. \\vspace{13em} Valide Valide suas solu\u00e7\u00f5es com um professor (ou um colega j\u00e1 validado) antes de prosseguir Vamos agora partir para leitura e escrita de strings no terminal. Para imprimir uma string no terminal basta usar o c\u00f3digo %s na string passada para o printf: char str [ 10 ] = \"world!\" ; printf ( \"hello %s \\n \" , str ); J\u00e1 a leitura de strings \u00e9 feita usando a fun\u00e7\u00e3o fgets , que l\u00ea uma linha inteira de caracteres a partir de um arquivo ou do terminal. Veja o exemplo abaixo. O \u00faltimo argumento stdin representa o terminal. char str [ 10 ]; fgets ( str , 10 , stdin ); // precisamos passar o tamanho m\u00e1ximo + 1 da nossa string. Tarefa 8 Fa\u00e7a, do zero, um programa que leia uma string (tamanho m\u00e1ximo 200) e crie uma nova string trocando toda letra por mai\u00fasculas. Seu programa dever\u00e1 imprimir a string original e sua vers\u00e3o em mai\u00fasculas. Seu programa deve funcionar para strings contendo n\u00fameros, s\u00edmbolos, espa\u00e7os e letras mai\u00fasculas e min\u00fasculas. Consulte a tabela abaixo, se necess\u00e1rio. Matrizes \u00b6 Vamos agora retomar os exerc\u00edcios de imgs/Lab4 e trabalhar com matrizes. Como visto na expositiva, matrizes em C nada mais s\u00e3o que vetores colocados um ap\u00f3s o outro. Seu acesso \u00e9 feito com a seguinte nota\u00e7\u00e3o int matriz [ 10 ][ 20 ]; matriz [ 0 ][ 3 ] /* acessa linha 0, coluna 3 */ scanf ( \"%d\" , & matriz [ 1 ][ 5 ]); // armazena inteiro digitado na posi\u00e7\u00e3o 1,5 */ O formato de imgs/Lab4 mais simples existente \u00e9 o pgm , que reprenta uma imagem em n\u00edveis de cinza como uma matriz com valores entre 0 (para preto) e 255 (para branco). Seu formato \u00e9 o seguinte. P2 W H 255 ......... Ou seja, primeiro lemos uma linha com a string \"P2\", depois dois inteiros w e h representando a largura e a altura da imagem, depois o valor 255. Ent\u00e3o lemos w * h valores representando os pixels da imagem. Disponibilizamos v\u00e1rias imgs/Lab4 de exemplo na pasta exemplos . Voc\u00eas podem abr\u00ed-las com qualquer editor de texto para ver seu conte\u00fado. Tip Nas tarefas abaixo estamos supondo que voc\u00ea usa < para passar o conte\u00fado das imgs/Lab4 exemplo para seu programa no terminal e > para salvar o resultado do terminal em uma nova imagem pgm . Para as tarefas abaixo voc\u00ea pode supor que as imgs/Lab4 tem tamanho m\u00e1ximo 512\\times 512 512\\times 512 . Para deixar seu c\u00f3digo mais limpo, defina duas constantes MAXW e MAXH para guardar estes valores. Tarefa 9 Crie, do zero, um programa que l\u00ea o cabe\u00e7alho de uma imagem pgm (primeiras tr\u00eas linhas) passada no terminal e imprima as dimens\u00f5es da imagem. N\u00e3o se esque\u00e7a de ler tamb\u00e9m o n\u00famero 255 na terceira linha. \\vspace{1em} Tarefa 10 Crie uma fun\u00e7\u00e3o void le_imagem(int mat[MAXH][MAXW], int w, int h) que l\u00ea os valores da matriz da imagem e os escreve em mat . \\vspace{1em} Tarefa 11 Crie uma fun\u00e7\u00e3o void escreve_imagem(int max[MAXH][MAXW], int w, int h) que escreve o cabe\u00e7alho e todos os pixels de uma imagem no terminal seguindo o formato pgm descrito acima. \\vspace{1em} Tarefa 12 Verifique que seu programa est\u00e1 correto fazendo uma fun\u00e7\u00e3o main que simplesmente l\u00ea uma imagem e logo em seguida a escreve no terminal. Verifique visualmente que a imagem de sa\u00edda \u00e9 igual a original. \\vspace{1em} Tarefa 13 Finalmente, crie uma fun\u00e7\u00e3o void limiar(int max[MAXH][MAXW], int w, int h, int lim) que aplica um limiar de 127 na imagem e chame-a na sua fun\u00e7\u00e3o main . Verifique visualmente que a imagem de sa\u00edda \u00e9 a esperada. \\vspace{1em}","title":"Lab 4 - Organiza\u00e7\u00e3o de dados"},{"location":"Lab4/#lab-4-organizacao-de-dados","text":"Na \u00faltima aula trabalhamos com conceitos b\u00e1sicos de C e com tipos de dados simples (inteiros e n\u00fameros fracion\u00e1rios). Hoje veremos as primeiras estruturas complexas em C : vetores, matrizes e strings.","title":"Lab 4 - Organiza\u00e7\u00e3o de dados"},{"location":"Lab4/#introducao","text":"Criamos vetores de tamanho fixo em C usando a seguinte sintaxe: long vetor [ 100 ]; Basta adicionar [] ap\u00f3s o tipo e teremos um vetor de tamanho constante (i.e. n\u00e3o dependente da entrada do usu\u00e1rio). N\u00e3o \u00e9 poss\u00edvel redimensionar o vetor . Depois de declarado ele ter\u00e1 para sempre o mesmo tamanho. O acesso a elementos tamb\u00e9m \u00e9 bastante simples: printf ( \"%ld \\n \" , vetor [ 0 ]); A linha acima imprime o primeira valor do vetor. O uso com scanf segue a mesma l\u00f3gica dos tipos simples: scanf ( \"%ld\" , & vetor [ 0 ]); Tarefa 1 O c\u00f3digo abaixo compila? Se sim, qual \u00e9 sua sa\u00edda? Tarefa 2 O c\u00f3digo acima est\u00e1 no arquivo exemplos/erro_comum1.c . Compile e execute ele. Os resultados foram os esperados? Se n\u00e3o, voc\u00ea consegue explicar o por que eles foram diferentes? Como podemos ver, o c\u00f3digo compila, mas seu comportamento \u00e9 indefinido por duas raz\u00f5es: O vetor n\u00e3o \u00e9 inicializado com 0 quando \u00e9 criado. A posi\u00e7\u00e3o vetor[5] n\u00e3o \u00e9 v\u00e1lida e pode resultar na leitura de dados inv\u00e1lidos da mem\u00f3ria. Tip Diferentemente de outras linguagens, C n\u00e3o verifica os \u00edndices automaticamente nem inicializa o elementos do vetor com 0. Al\u00e9m disto, n\u00e3o \u00e9 poss\u00edvel obter o tamanho de um vetor a partir de seu nome. Um ponto importante \u00e9 que o sistema de tipos n\u00e3o permite a convers\u00e3o/passagem de vetores do mesmo tipo mas de tamanhos diferentes. Assim, a fun\u00e7\u00e3o abaixo n\u00e3o aceitaria como argumento a vari\u00e1vel double arr[4] , pois s\u00f3 aceita vetores de tamanho 3. double soma ( double arr [ 3 ]) { double s = 0 ; for ( int i = 0 ; i < 3 ; i ++ ) { s += arr [ i ]; } return s ; } Para faz\u00ea-la aceitar vetores de tamanho qualquer poder\u00edamos mudar sua assinatura para n\u00e3o checar o tamanho do vetor e pass\u00e1-lo como argumento da fun\u00e7\u00e3o. double soma ( double arr [], int n ); Tarefa 3 Modifique a fun\u00e7\u00e3o soma acima para aceitar vetores de qualquer tamanho. Lembre-se que arrays em C n\u00e3o conhecem seu tamanho, ent\u00e3o \u00e9 de sua responsabilidade acessar somente elementos v\u00e1lidos e checar se o vetor n\u00e3o est\u00e1 vazio (ou seja, n < 1 ) \\vspace{15em} !!! example \"Tarefa 4**: Vamos agora juntar vetores com a aula passada e com a leitura de ontem: escreva do zero um programa que Leia um inteiro n do terminal (n\u00famero de elementos do vetor) Leia n n\u00fameros fracion\u00e1rios e guard\u00e1-los em um array. Chame uma fun\u00e7\u00e3o para calcular a m\u00e9dia do vetor. Imprima a m\u00e9dia calculada. Seu programa dever\u00e1 calcular a m\u00e9dia usando uma fun\u00e7\u00e3o avg escrita por voc\u00ea mesmo e pode supor que n < 100 . Para facilitar seus testes, escreva dois arquivos de entrada e use < para rodar o programa. Tarefa 5 Modifique seu programa acima para que ele imprima tamb\u00e9m a vari\u00e2ncia do vetor.","title":"Introdu\u00e7\u00e3o"},{"location":"Lab4/#strings","text":"Como visto na expositiva, strings s\u00e3o vetores de caracteres sendo que o \u00faltimo elemento da string cont\u00e9m um caractere '\\0' . Logo, uma string declarada como char str[100] pode guardar strings de at\u00e9 99 caracteres (mais 1 para o '\\0' ). Se a string tiver comprimento menor o restante das posi\u00e7\u00f5es simplesmente n\u00e3o \u00e9 utilizado. !!! example \"Tarefa 6**: Em Python n\u00e3o existe diferen\u00e7a entre \"a\" e 'a' . Isto \u00e9 verdade em C ? \\vspace{5em} Tarefa 7 Um aluno fez a seguinte fun\u00e7\u00e3o para c\u00f3pia de strings. void copia_string ( char str1 [], char str2 []) { int i = 0 ; while ( str1 [ i ] != '\\0' ) { str2 [ i ] = str1 [ i ]; i ++ ; } } Existem pelo menos dois problemas graves neste c\u00f3digo. Voc\u00ea consegue identific\u00e1-los? \\vspace{8em} Tarefa 8 Escreva abaixo uma fun\u00e7\u00e3o que recebe uma string como par\u00e2metro e retorne quantas vezes o caractere 1 aparece. \\vspace{15em} Tarefa 9 Escreva abaixo uma fun\u00e7\u00e3o que recebe uma string como par\u00e2metro e retorna 1 se ela \u00e9 um pal\u00edndromo ou 0 caso contr\u00e1rio. \\vspace{13em} Valide Valide suas solu\u00e7\u00f5es com um professor (ou um colega j\u00e1 validado) antes de prosseguir Vamos agora partir para leitura e escrita de strings no terminal. Para imprimir uma string no terminal basta usar o c\u00f3digo %s na string passada para o printf: char str [ 10 ] = \"world!\" ; printf ( \"hello %s \\n \" , str ); J\u00e1 a leitura de strings \u00e9 feita usando a fun\u00e7\u00e3o fgets , que l\u00ea uma linha inteira de caracteres a partir de um arquivo ou do terminal. Veja o exemplo abaixo. O \u00faltimo argumento stdin representa o terminal. char str [ 10 ]; fgets ( str , 10 , stdin ); // precisamos passar o tamanho m\u00e1ximo + 1 da nossa string. Tarefa 8 Fa\u00e7a, do zero, um programa que leia uma string (tamanho m\u00e1ximo 200) e crie uma nova string trocando toda letra por mai\u00fasculas. Seu programa dever\u00e1 imprimir a string original e sua vers\u00e3o em mai\u00fasculas. Seu programa deve funcionar para strings contendo n\u00fameros, s\u00edmbolos, espa\u00e7os e letras mai\u00fasculas e min\u00fasculas. Consulte a tabela abaixo, se necess\u00e1rio.","title":"Strings"},{"location":"Lab4/#matrizes","text":"Vamos agora retomar os exerc\u00edcios de imgs/Lab4 e trabalhar com matrizes. Como visto na expositiva, matrizes em C nada mais s\u00e3o que vetores colocados um ap\u00f3s o outro. Seu acesso \u00e9 feito com a seguinte nota\u00e7\u00e3o int matriz [ 10 ][ 20 ]; matriz [ 0 ][ 3 ] /* acessa linha 0, coluna 3 */ scanf ( \"%d\" , & matriz [ 1 ][ 5 ]); // armazena inteiro digitado na posi\u00e7\u00e3o 1,5 */ O formato de imgs/Lab4 mais simples existente \u00e9 o pgm , que reprenta uma imagem em n\u00edveis de cinza como uma matriz com valores entre 0 (para preto) e 255 (para branco). Seu formato \u00e9 o seguinte. P2 W H 255 ......... Ou seja, primeiro lemos uma linha com a string \"P2\", depois dois inteiros w e h representando a largura e a altura da imagem, depois o valor 255. Ent\u00e3o lemos w * h valores representando os pixels da imagem. Disponibilizamos v\u00e1rias imgs/Lab4 de exemplo na pasta exemplos . Voc\u00eas podem abr\u00ed-las com qualquer editor de texto para ver seu conte\u00fado. Tip Nas tarefas abaixo estamos supondo que voc\u00ea usa < para passar o conte\u00fado das imgs/Lab4 exemplo para seu programa no terminal e > para salvar o resultado do terminal em uma nova imagem pgm . Para as tarefas abaixo voc\u00ea pode supor que as imgs/Lab4 tem tamanho m\u00e1ximo 512\\times 512 512\\times 512 . Para deixar seu c\u00f3digo mais limpo, defina duas constantes MAXW e MAXH para guardar estes valores. Tarefa 9 Crie, do zero, um programa que l\u00ea o cabe\u00e7alho de uma imagem pgm (primeiras tr\u00eas linhas) passada no terminal e imprima as dimens\u00f5es da imagem. N\u00e3o se esque\u00e7a de ler tamb\u00e9m o n\u00famero 255 na terceira linha. \\vspace{1em} Tarefa 10 Crie uma fun\u00e7\u00e3o void le_imagem(int mat[MAXH][MAXW], int w, int h) que l\u00ea os valores da matriz da imagem e os escreve em mat . \\vspace{1em} Tarefa 11 Crie uma fun\u00e7\u00e3o void escreve_imagem(int max[MAXH][MAXW], int w, int h) que escreve o cabe\u00e7alho e todos os pixels de uma imagem no terminal seguindo o formato pgm descrito acima. \\vspace{1em} Tarefa 12 Verifique que seu programa est\u00e1 correto fazendo uma fun\u00e7\u00e3o main que simplesmente l\u00ea uma imagem e logo em seguida a escreve no terminal. Verifique visualmente que a imagem de sa\u00edda \u00e9 igual a original. \\vspace{1em} Tarefa 13 Finalmente, crie uma fun\u00e7\u00e3o void limiar(int max[MAXH][MAXW], int w, int h, int lim) que aplica um limiar de 127 na imagem e chame-a na sua fun\u00e7\u00e3o main . Verifique visualmente que a imagem de sa\u00edda \u00e9 a esperada. \\vspace{1em}","title":"Matrizes"},{"location":"Lab5/","text":"Lab 5 - juntando tudo \u00b6 Info Este roteiro n\u00e3o apresenta nenhum conceito novo. Voc\u00eas podem faz\u00ea-lo apenas com o que j\u00e1 foi apresentado nos roteiros anteriores. Se voc\u00ea est\u00e1 precisando consultar materiais extras \u00e9 um sinal de que sua solu\u00e7\u00e3o \u00e9 complicada demais. Vamos neste roteiro revisar os conceitos dos dois roteiros anteriores fazendo modifica\u00e7\u00f5es para tornar seu programa mais leg\u00edvel e organizado. Example Crie uma estrurura imagem para guardar largura, altura e a matriz da imagem. Voc\u00ea pode supor que ela tem tamanho m\u00e1ximo 640\\times 480 640\\times 480 . Example Modifique sua fun\u00e7\u00e3o le_imagem que carrega o conte\u00fado de uma imagem do terminal e escreve em uma estrutura imagem . Quais par\u00e2metros sua fun\u00e7\u00e3o recebe? !!example Modifique sua fun\u00e7\u00e3o escreve_imagem para receber um tipo imagem . Voc\u00ea deve usar apontadores nesta fun\u00e7\u00e3o? Example Modifique sua fun\u00e7\u00e3o limiar para receber um tipo imagem . Voc\u00ea deve usar apontadores nesta fun\u00e7\u00e3o? Warning Valide sua implementa\u00e7\u00e3o com os professores antes de seguir. Exerc\u00edcios avan\u00e7ados \u00b6 Example Crop : crie uma fun\u00e7\u00e3o crop que corta uma imagem. Sua fun\u00e7\u00e3o dever\u00e1 receber dois tipos imagem : um para a imagem original e outra para a imagem cortada. Quais par\u00e2metros sua fun\u00e7\u00e3o deve receber? Voc\u00ea deve usar apontadores? Example Borramento : crie uma fun\u00e7\u00e3o blur que faz o borramento de uma imagem. Ela dever\u00e1 receber dois tipos imagem : um contendo a imagem original e um que receber\u00e1 a imagem processada. Para borrar a imagem compute, para cada ponto, a m\u00e9dia entre seu valor e o valor de seus vizinhos (incluindo diagonais). Example Detector de bordas : voc\u00ea pode detectar bordas em uma imagem computando, para cada ponto, a diferen\u00e7a entre 4 vezes seu valor e o valor dos seus vizinhos. Warning Valide visualmente cada exerc\u00edcio antes de prosseguir.","title":"Lab 5 - juntando tudo"},{"location":"Lab5/#lab-5-juntando-tudo","text":"Info Este roteiro n\u00e3o apresenta nenhum conceito novo. Voc\u00eas podem faz\u00ea-lo apenas com o que j\u00e1 foi apresentado nos roteiros anteriores. Se voc\u00ea est\u00e1 precisando consultar materiais extras \u00e9 um sinal de que sua solu\u00e7\u00e3o \u00e9 complicada demais. Vamos neste roteiro revisar os conceitos dos dois roteiros anteriores fazendo modifica\u00e7\u00f5es para tornar seu programa mais leg\u00edvel e organizado. Example Crie uma estrurura imagem para guardar largura, altura e a matriz da imagem. Voc\u00ea pode supor que ela tem tamanho m\u00e1ximo 640\\times 480 640\\times 480 . Example Modifique sua fun\u00e7\u00e3o le_imagem que carrega o conte\u00fado de uma imagem do terminal e escreve em uma estrutura imagem . Quais par\u00e2metros sua fun\u00e7\u00e3o recebe? !!example Modifique sua fun\u00e7\u00e3o escreve_imagem para receber um tipo imagem . Voc\u00ea deve usar apontadores nesta fun\u00e7\u00e3o? Example Modifique sua fun\u00e7\u00e3o limiar para receber um tipo imagem . Voc\u00ea deve usar apontadores nesta fun\u00e7\u00e3o? Warning Valide sua implementa\u00e7\u00e3o com os professores antes de seguir.","title":"Lab 5 - juntando tudo"},{"location":"Lab5/#exercicios-avancados","text":"Example Crop : crie uma fun\u00e7\u00e3o crop que corta uma imagem. Sua fun\u00e7\u00e3o dever\u00e1 receber dois tipos imagem : um para a imagem original e outra para a imagem cortada. Quais par\u00e2metros sua fun\u00e7\u00e3o deve receber? Voc\u00ea deve usar apontadores? Example Borramento : crie uma fun\u00e7\u00e3o blur que faz o borramento de uma imagem. Ela dever\u00e1 receber dois tipos imagem : um contendo a imagem original e um que receber\u00e1 a imagem processada. Para borrar a imagem compute, para cada ponto, a m\u00e9dia entre seu valor e o valor de seus vizinhos (incluindo diagonais). Example Detector de bordas : voc\u00ea pode detectar bordas em uma imagem computando, para cada ponto, a diferen\u00e7a entre 4 vezes seu valor e o valor dos seus vizinhos. Warning Valide visualmente cada exerc\u00edcio antes de prosseguir.","title":"Exerc\u00edcios avan\u00e7ados"},{"location":"day1-embarcados-parte2/","text":"Embarcados - Parte 2 \u00b6 Melhorando o desempenho \u00b6 Assim como qualquer sistema microprocessado podemos ajustar diversos par\u00e2metros interno de funcionamento do microcontrolador. Sendo o clock (frequ\u00eancia de opera\u00e7\u00e3o) um dos fatores que possui grande impacto na aplica\u00e7\u00e3o. \u00c9 natural pensarmos que quanto maior a frequ\u00eancia do clock maior ser\u00e1 o gasto energ\u00e9tico de um sistema, lembre de camada f\u00edsica onde vimos que o gasto energ\u00e9tico em sistemas digitais constru\u00eddos com MOSFET \u00e9: \\alpha C V_{DD}^2 f \\alpha C V_{DD}^2 f onde : \\alpha \\alpha : fator de chaveamento (influenciado pelo c\u00f3digo) C C : capacit\u00e2ncia V V : tens\u00e3o de opera\u00e7\u00e3o f f : frequ\u00eancia de chaveamento Portanto quanto maior a frequ\u00eancia de chaveamento maior ser\u00e1 o gasto energ\u00e9tico do sistema, mas um detalhe deve ser levado em considera\u00e7\u00e3o: quanto maior a frequ\u00eancia do clock mais r\u00e1pido uma tarefa \u00e9 realizada e mais rapidamente um sistema pode entrar em modo de baixo consumo energ\u00e9tico sleep mode, suspens\u00e3o, .... . Note Recentemente o kernel do linux removeu o perfil ondemand de seus modos de opera\u00e7\u00e3o , esse modo alterava dinamicamente a frequ\u00eancia de opera\u00e7\u00e3o do processador para alta quando uma grande carga de processamento era demandada e para mais baixa quando o processador estava em baixo uso. A ideia inicial disso era a melhoria do consumo energ\u00e9tico j\u00e1 que o processador se ajustava a demanda do sistema. Por\u00e9m detectou-se que isso n\u00e3o era verdade, j\u00e1 que esse modo tardava o processador de entrar no modo de sleep mais profundo al\u00e9m de demandar processamento para verificar a carga atual do processador. Alterando a frequ\u00eancia de opera\u00e7\u00e3o \u00b6 O arquivo .h localizado em: src/config/conf_clock.h \u00e9 respons\u00e1vel pela configura\u00e7\u00e3o do clock do microcontrolador. Note que no trecho de c\u00f3digo referente ao Prescaler existem diversas op\u00e7\u00f5es que podem ser escolhidas, a atual est\u00e1 definda como: // ===== Processor Clock (HCLK) Prescaler Options (Fhclk = Fsys / (SYSCLK_PRES)) //#define CONFIG_SYSCLK_PRES SYSCLK_PRES_1 //#define CONFIG_SYSCLK_PRES SYSCLK_PRES_2 //#define CONFIG_SYSCLK_PRES SYSCLK_PRES_4 //#define CONFIG_SYSCLK_PRES SYSCLK_PRES_8 //#define CONFIG_SYSCLK_PRES SYSCLK_PRES_16 //#define CONFIG_SYSCLK_PRES SYSCLK_PRES_32 #define CONFIG_SYSCLK_PRES SYSCLK_PRES_64 //#define CONFIG_SYSCLK_PRES SYSCLK_PRES_3 Onde Fsys \u00e9 equivalente a 300Mhz . Na configura\u00e7\u00e3o inicial a frequ\u00eancia do processador \u00e9 300Mhz/64 = 4.5 MHz, altere esse trecho para a forma a seguir, selecionando a frequ\u00eancia do principal do uC para 300Mhz. // ===== Processor Clock (HCLK) Prescaler Options (Fhclk = Fsys / (SYSCLK_PRES)) #define CONFIG_SYSCLK_PRES SYSCLK_PRES_1 //#define CONFIG_SYSCLK_PRES SYSCLK_PRES_2 //#define CONFIG_SYSCLK_PRES SYSCLK_PRES_4 //#define CONFIG_SYSCLK_PRES SYSCLK_PRES_8 //#define CONFIG_SYSCLK_PRES SYSCLK_PRES_16 //#define CONFIG_SYSCLK_PRES SYSCLK_PRES_32 //#define CONFIG_SYSCLK_PRES SYSCLK_PRES_64 //#define CONFIG_SYSCLK_PRES SYSCLK_PRES_3 Testando Compile e embarque o firmware com essa mudan\u00e7a. Verifique a nova taxa de atualiza\u00e7\u00e3o do LCD, melhorou? Como tudo isso funciona? \u00b6 Em uma vis\u00e3o mais geral podemos analisar o sistema como um kit de desenvolvimento e um display LCD: Sistema detalhado \u00b6 Uma an\u00e1lise mais detalhada do projeto pode ser visto no diagrama de blocos a seguir: Esse projeto \u00e9 implementando em um kit de desenvolvimento para microcontroladores ARM Cortex M7 do fabricante Microchip/ATMEL (a ARM n\u00e3o fabrica chips, somente propriedade intelectual). Esse microcontrolador \u00e9 chamado de SAME70 e o kit de desenvolvimento SAME70-XPLD . O kit possui al\u00e9m do microcontrolador toda a infraestrutura necess\u00e1ria para o seu funcionamento e mais alguns perif\u00e9ricos que podem ser \u00fateis no desenvolvimento de um projeto (gerenciador de energia, gravador, mem\u00f3ria, bot\u00e3o, led). Pelo diagrama detalhado nota-se que a comunica\u00e7\u00e3o do uC com o LCD \u00e9 realizado via uma interface serial (lembra da UART de Camada F\u00edsica? aqui usa-se uma outra comunica\u00e7\u00e3o similar chamada de SPI ). No m\u00f3dulo do LCD um chip dedicado para o controle do display ( ili9488 , da mesma fam\u00edlia do display de elementos de sistema) recebe instru\u00e7\u00f5es do uC e atualiza o LCD. Note Microcontroladores n\u00e3o necessitam geralmente de mem\u00f3ria externa para o seu funcionamento, por\u00e9m \u00e9 a mesma deve sert utilizada quando a aplica\u00e7\u00e3o necessita de uma quantidade razo\u00e1vel de mem\u00f3ria. No caso desse microcontrolador possui internamente \"somente\": 384 KBytes de RAM 2 MBytes de ROM \"somente\" se compararmos com a capacidade de armazenamento de um computador, mas se compararmos com outros microcontroladores esse possui muita mem\u00f3ria. Essa memoria interna do uC n\u00e3o foi suficiente para a nossa aplica\u00e7\u00e3o de exemplo, tivermos que recorrer a essa mem\u00f3ria externa (SDRAM). microcontrolador \u00b6 Podemos detalhar ainda mais o sistema se detalharmos o que est\u00e1 sendo usado no microcontrolador, entendendo todas as partes em uso. Pelo diagrama podemos notar os seguintes \"perif\u00e9ricos\": CORE M7: Unidade de processamento ARM. RAM: Unidade de mem\u00f3ria que \u00e9 usada durante execu\u00e7\u00e3o (vari\u00e1veis). ROM: Unidade de mem\u00f3ria usada para armazenar o programa e constantes . External Memory Controller: Perif\u00e9rico respons\u00e1vel por gerenciar uma mem\u00f3ria externa. SPI: Perif\u00e9rico respons\u00e1vel pela comunica\u00e7\u00e3o serial SPI e interface com o m\u00f3dulo LCD. PIO: Perif\u00e9rico respons\u00e1vel pela interface com entradas e sa\u00eddas digitais (Parallel Input/OutPut). . Firmware \u00b6 O arquivo principal desse projeto \u00e9 o main.c (\u00e9 muito comum em C a fun\u00e7\u00e3o main() estar no arquivo main.c, mas n\u00e3o \u00e9 necess\u00e1rio), esse c\u00f3digo fonte possui a fun\u00e7\u00e3o main() que \u00e9 a primeira a ser chamada na inicializa\u00e7\u00e3o do sistema. Nessa fun\u00e7\u00e3o inicializa-se primeiro o sistema embarcado e seus perif\u00e9ricos (clock, LCD, bot\u00e3o, mem\u00f3ria) via a chamada de fun\u00e7\u00e3o initBoardMutirao() . Ap\u00f3s inicializado a placa chama-se a fun\u00e7\u00e3o imgshow(...) que possui toda a parte respons\u00e1vel por exibir a imagem no LCD. Trecho do arquivo main.c int main (){ uint32_t time ; // variavel para armazenar tempo de processamento uint8_t imageSelect = 1 ; // variavle para selecao da imagem a ser exibida // quando o botao for pressionado // 1 = imagem processada // 0 = imagem orignal // inicializa placa e seus perifericos initBoardMutirao (); // exibe imagem orignal, tempo de processamento suprimido. imgShow ( imgRaw , 0 ); ... A fun\u00e7\u00e3o imgShow possui dois par\u00e2metros: a imagem image[320][320] a ser exibida, passada como uma matriz de tamanho j\u00e1 definido, e o tempo de processamento a ser exibido no LCD: void imgShow ( ili9488_color_t image [ 320 ][ 320 ], uint32_t time ){...} Ap\u00f3s essa etapa o microcontrolador entra em um loop infinito ( while(1){} ) que verifica uma vari\u00e1vel chamada de buttonFlag que \u00e9 alterada via uma interrup\u00e7\u00e3o para o valor 1 sempre que o bot\u00e3o for pressionado. // super loop // aplicacoes embarcadas n\u00e3o devem sair do while(1). while ( 1 ) { // se buttonFlag = 1 existe alteracao no estado do botao if ( buttonFlag ){","title":"Parte 2"},{"location":"day1-embarcados-parte2/#embarcados-parte-2","text":"","title":"Embarcados - Parte 2"},{"location":"day1-embarcados-parte2/#melhorando-o-desempenho","text":"Assim como qualquer sistema microprocessado podemos ajustar diversos par\u00e2metros interno de funcionamento do microcontrolador. Sendo o clock (frequ\u00eancia de opera\u00e7\u00e3o) um dos fatores que possui grande impacto na aplica\u00e7\u00e3o. \u00c9 natural pensarmos que quanto maior a frequ\u00eancia do clock maior ser\u00e1 o gasto energ\u00e9tico de um sistema, lembre de camada f\u00edsica onde vimos que o gasto energ\u00e9tico em sistemas digitais constru\u00eddos com MOSFET \u00e9: \\alpha C V_{DD}^2 f \\alpha C V_{DD}^2 f onde : \\alpha \\alpha : fator de chaveamento (influenciado pelo c\u00f3digo) C C : capacit\u00e2ncia V V : tens\u00e3o de opera\u00e7\u00e3o f f : frequ\u00eancia de chaveamento Portanto quanto maior a frequ\u00eancia de chaveamento maior ser\u00e1 o gasto energ\u00e9tico do sistema, mas um detalhe deve ser levado em considera\u00e7\u00e3o: quanto maior a frequ\u00eancia do clock mais r\u00e1pido uma tarefa \u00e9 realizada e mais rapidamente um sistema pode entrar em modo de baixo consumo energ\u00e9tico sleep mode, suspens\u00e3o, .... . Note Recentemente o kernel do linux removeu o perfil ondemand de seus modos de opera\u00e7\u00e3o , esse modo alterava dinamicamente a frequ\u00eancia de opera\u00e7\u00e3o do processador para alta quando uma grande carga de processamento era demandada e para mais baixa quando o processador estava em baixo uso. A ideia inicial disso era a melhoria do consumo energ\u00e9tico j\u00e1 que o processador se ajustava a demanda do sistema. Por\u00e9m detectou-se que isso n\u00e3o era verdade, j\u00e1 que esse modo tardava o processador de entrar no modo de sleep mais profundo al\u00e9m de demandar processamento para verificar a carga atual do processador.","title":"Melhorando o desempenho"},{"location":"day1-embarcados-parte2/#alterando-a-frequencia-de-operacao","text":"O arquivo .h localizado em: src/config/conf_clock.h \u00e9 respons\u00e1vel pela configura\u00e7\u00e3o do clock do microcontrolador. Note que no trecho de c\u00f3digo referente ao Prescaler existem diversas op\u00e7\u00f5es que podem ser escolhidas, a atual est\u00e1 definda como: // ===== Processor Clock (HCLK) Prescaler Options (Fhclk = Fsys / (SYSCLK_PRES)) //#define CONFIG_SYSCLK_PRES SYSCLK_PRES_1 //#define CONFIG_SYSCLK_PRES SYSCLK_PRES_2 //#define CONFIG_SYSCLK_PRES SYSCLK_PRES_4 //#define CONFIG_SYSCLK_PRES SYSCLK_PRES_8 //#define CONFIG_SYSCLK_PRES SYSCLK_PRES_16 //#define CONFIG_SYSCLK_PRES SYSCLK_PRES_32 #define CONFIG_SYSCLK_PRES SYSCLK_PRES_64 //#define CONFIG_SYSCLK_PRES SYSCLK_PRES_3 Onde Fsys \u00e9 equivalente a 300Mhz . Na configura\u00e7\u00e3o inicial a frequ\u00eancia do processador \u00e9 300Mhz/64 = 4.5 MHz, altere esse trecho para a forma a seguir, selecionando a frequ\u00eancia do principal do uC para 300Mhz. // ===== Processor Clock (HCLK) Prescaler Options (Fhclk = Fsys / (SYSCLK_PRES)) #define CONFIG_SYSCLK_PRES SYSCLK_PRES_1 //#define CONFIG_SYSCLK_PRES SYSCLK_PRES_2 //#define CONFIG_SYSCLK_PRES SYSCLK_PRES_4 //#define CONFIG_SYSCLK_PRES SYSCLK_PRES_8 //#define CONFIG_SYSCLK_PRES SYSCLK_PRES_16 //#define CONFIG_SYSCLK_PRES SYSCLK_PRES_32 //#define CONFIG_SYSCLK_PRES SYSCLK_PRES_64 //#define CONFIG_SYSCLK_PRES SYSCLK_PRES_3 Testando Compile e embarque o firmware com essa mudan\u00e7a. Verifique a nova taxa de atualiza\u00e7\u00e3o do LCD, melhorou?","title":"Alterando a frequ\u00eancia de opera\u00e7\u00e3o"},{"location":"day1-embarcados-parte2/#como-tudo-isso-funciona","text":"Em uma vis\u00e3o mais geral podemos analisar o sistema como um kit de desenvolvimento e um display LCD:","title":"Como tudo isso funciona?"},{"location":"day1-embarcados-parte2/#sistema-detalhado","text":"Uma an\u00e1lise mais detalhada do projeto pode ser visto no diagrama de blocos a seguir: Esse projeto \u00e9 implementando em um kit de desenvolvimento para microcontroladores ARM Cortex M7 do fabricante Microchip/ATMEL (a ARM n\u00e3o fabrica chips, somente propriedade intelectual). Esse microcontrolador \u00e9 chamado de SAME70 e o kit de desenvolvimento SAME70-XPLD . O kit possui al\u00e9m do microcontrolador toda a infraestrutura necess\u00e1ria para o seu funcionamento e mais alguns perif\u00e9ricos que podem ser \u00fateis no desenvolvimento de um projeto (gerenciador de energia, gravador, mem\u00f3ria, bot\u00e3o, led). Pelo diagrama detalhado nota-se que a comunica\u00e7\u00e3o do uC com o LCD \u00e9 realizado via uma interface serial (lembra da UART de Camada F\u00edsica? aqui usa-se uma outra comunica\u00e7\u00e3o similar chamada de SPI ). No m\u00f3dulo do LCD um chip dedicado para o controle do display ( ili9488 , da mesma fam\u00edlia do display de elementos de sistema) recebe instru\u00e7\u00f5es do uC e atualiza o LCD. Note Microcontroladores n\u00e3o necessitam geralmente de mem\u00f3ria externa para o seu funcionamento, por\u00e9m \u00e9 a mesma deve sert utilizada quando a aplica\u00e7\u00e3o necessita de uma quantidade razo\u00e1vel de mem\u00f3ria. No caso desse microcontrolador possui internamente \"somente\": 384 KBytes de RAM 2 MBytes de ROM \"somente\" se compararmos com a capacidade de armazenamento de um computador, mas se compararmos com outros microcontroladores esse possui muita mem\u00f3ria. Essa memoria interna do uC n\u00e3o foi suficiente para a nossa aplica\u00e7\u00e3o de exemplo, tivermos que recorrer a essa mem\u00f3ria externa (SDRAM).","title":"Sistema detalhado"},{"location":"day1-embarcados-parte2/#microcontrolador","text":"Podemos detalhar ainda mais o sistema se detalharmos o que est\u00e1 sendo usado no microcontrolador, entendendo todas as partes em uso. Pelo diagrama podemos notar os seguintes \"perif\u00e9ricos\": CORE M7: Unidade de processamento ARM. RAM: Unidade de mem\u00f3ria que \u00e9 usada durante execu\u00e7\u00e3o (vari\u00e1veis). ROM: Unidade de mem\u00f3ria usada para armazenar o programa e constantes . External Memory Controller: Perif\u00e9rico respons\u00e1vel por gerenciar uma mem\u00f3ria externa. SPI: Perif\u00e9rico respons\u00e1vel pela comunica\u00e7\u00e3o serial SPI e interface com o m\u00f3dulo LCD. PIO: Perif\u00e9rico respons\u00e1vel pela interface com entradas e sa\u00eddas digitais (Parallel Input/OutPut). .","title":"microcontrolador"},{"location":"day1-embarcados-parte2/#firmware","text":"O arquivo principal desse projeto \u00e9 o main.c (\u00e9 muito comum em C a fun\u00e7\u00e3o main() estar no arquivo main.c, mas n\u00e3o \u00e9 necess\u00e1rio), esse c\u00f3digo fonte possui a fun\u00e7\u00e3o main() que \u00e9 a primeira a ser chamada na inicializa\u00e7\u00e3o do sistema. Nessa fun\u00e7\u00e3o inicializa-se primeiro o sistema embarcado e seus perif\u00e9ricos (clock, LCD, bot\u00e3o, mem\u00f3ria) via a chamada de fun\u00e7\u00e3o initBoardMutirao() . Ap\u00f3s inicializado a placa chama-se a fun\u00e7\u00e3o imgshow(...) que possui toda a parte respons\u00e1vel por exibir a imagem no LCD. Trecho do arquivo main.c int main (){ uint32_t time ; // variavel para armazenar tempo de processamento uint8_t imageSelect = 1 ; // variavle para selecao da imagem a ser exibida // quando o botao for pressionado // 1 = imagem processada // 0 = imagem orignal // inicializa placa e seus perifericos initBoardMutirao (); // exibe imagem orignal, tempo de processamento suprimido. imgShow ( imgRaw , 0 ); ... A fun\u00e7\u00e3o imgShow possui dois par\u00e2metros: a imagem image[320][320] a ser exibida, passada como uma matriz de tamanho j\u00e1 definido, e o tempo de processamento a ser exibido no LCD: void imgShow ( ili9488_color_t image [ 320 ][ 320 ], uint32_t time ){...} Ap\u00f3s essa etapa o microcontrolador entra em um loop infinito ( while(1){} ) que verifica uma vari\u00e1vel chamada de buttonFlag que \u00e9 alterada via uma interrup\u00e7\u00e3o para o valor 1 sempre que o bot\u00e3o for pressionado. // super loop // aplicacoes embarcadas n\u00e3o devem sair do while(1). while ( 1 ) { // se buttonFlag = 1 existe alteracao no estado do botao if ( buttonFlag ){","title":"Firmware"},{"location":"day1-embarcados/","text":"Embarcados - Parte 1 \u00b6 Warning Essa atividade demanda sistema operacional Windows, conforme descrito na infra de Computa\u00e7\u00e3o Embarcada Nessa aula iremos trabalhar com os conceitos b\u00e1sicos da linguagem C aplicados ao processamento de imagem em sistemas embarcados. Para isso utilizaremos um kit de desenvolvimento com um microcontrolador ARM cortex M7 e um LCD colorido de 480x320 px conectado a esse kit. Detalhe do material utilizado Kit : SAME70-XPLD Microcontrolador : ARM Cortex M7 LCD : maXTouch Xplained Pro Parte 1 \u00b6 Nesse primeira etapa iremos executar um c\u00f3digo exemplo no sistema embarcado, para isso ser\u00e1 necess\u00e1rio: Conectar o LCD ao kit Conectar o kit no computador Abrir e compilar o projeto no AtmelStudio Programar o microcontrolador Validar o resultado esperado Antes de prosseguir voc\u00ea deve ter o reposit\u00f3rio Labs C j\u00e1 clonado no seu computador (Windows). Conectando o LCD \u00b6 Warning Tome cuidado ao manusear a placa, n\u00e3o coloque ela sobre outros materiais. Considerando que os pr\u00e9 requisitos para a disciplina de Computa\u00e7\u00e3o Embarcada j\u00e1 foram instalados. Conectar o USB do programador no computador: Tip Note que a placa possui dois USB: DEBUG USB , usado para programar o uC e TARGET USB usado para projetos que demandam conectividade via USB. AtmelStudio \u00b6 Abra o projeto exemplo ( SAME70-MutiraoC ) localizado no reposit\u00f3rio do mutir\u00e3o http://github.com/insper/MutiraoC/01-DayOne/SAEM70-MutiraoC O projeto ir\u00e1 abrir na IDE do AtmelStudio como imagem a seguir: . Compilar e programar \u00b6 A etapa atual ser\u00e1 a de embarcar o c\u00f3digo exemplo no uC, para isso basta clicar em Start Without Debug : . Testando \u00b6 Uma vez embarcado o exemplo o LCD dever\u00e1 exibir uma imagem. A primeira imagem que aparece \u00e9 a imagem original sem nenhum tipo de modifica\u00e7\u00e3o, ao apertar o bot\u00e3o SW0 do kit de desenvolvimento uma fun\u00e7\u00e3o ( imageProcess() ) \u00e9 chamada e a imagem orignal \u00e9 processada e seu resultado exibido na tela (junto com o tempo de processamento). . Tip Se pressionar o outro bot\u00e3o o uC ser\u00e1 reiniciado (reset). Note Reparou que o sistema de modo geral est\u00e1 muito lento? Vamos melhorar isso!","title":"Parte 1"},{"location":"day1-embarcados/#embarcados-parte-1","text":"Warning Essa atividade demanda sistema operacional Windows, conforme descrito na infra de Computa\u00e7\u00e3o Embarcada Nessa aula iremos trabalhar com os conceitos b\u00e1sicos da linguagem C aplicados ao processamento de imagem em sistemas embarcados. Para isso utilizaremos um kit de desenvolvimento com um microcontrolador ARM cortex M7 e um LCD colorido de 480x320 px conectado a esse kit. Detalhe do material utilizado Kit : SAME70-XPLD Microcontrolador : ARM Cortex M7 LCD : maXTouch Xplained Pro","title":"Embarcados - Parte 1"},{"location":"day1-embarcados/#parte-1","text":"Nesse primeira etapa iremos executar um c\u00f3digo exemplo no sistema embarcado, para isso ser\u00e1 necess\u00e1rio: Conectar o LCD ao kit Conectar o kit no computador Abrir e compilar o projeto no AtmelStudio Programar o microcontrolador Validar o resultado esperado Antes de prosseguir voc\u00ea deve ter o reposit\u00f3rio Labs C j\u00e1 clonado no seu computador (Windows).","title":"Parte 1"},{"location":"day1-embarcados/#conectando-o-lcd","text":"Warning Tome cuidado ao manusear a placa, n\u00e3o coloque ela sobre outros materiais. Considerando que os pr\u00e9 requisitos para a disciplina de Computa\u00e7\u00e3o Embarcada j\u00e1 foram instalados. Conectar o USB do programador no computador: Tip Note que a placa possui dois USB: DEBUG USB , usado para programar o uC e TARGET USB usado para projetos que demandam conectividade via USB.","title":"Conectando o LCD"},{"location":"day1-embarcados/#atmelstudio","text":"Abra o projeto exemplo ( SAME70-MutiraoC ) localizado no reposit\u00f3rio do mutir\u00e3o http://github.com/insper/MutiraoC/01-DayOne/SAEM70-MutiraoC O projeto ir\u00e1 abrir na IDE do AtmelStudio como imagem a seguir: .","title":"AtmelStudio"},{"location":"day1-embarcados/#compilar-e-programar","text":"A etapa atual ser\u00e1 a de embarcar o c\u00f3digo exemplo no uC, para isso basta clicar em Start Without Debug : .","title":"Compilar e programar"},{"location":"day1-embarcados/#testando","text":"Uma vez embarcado o exemplo o LCD dever\u00e1 exibir uma imagem. A primeira imagem que aparece \u00e9 a imagem original sem nenhum tipo de modifica\u00e7\u00e3o, ao apertar o bot\u00e3o SW0 do kit de desenvolvimento uma fun\u00e7\u00e3o ( imageProcess() ) \u00e9 chamada e a imagem orignal \u00e9 processada e seu resultado exibido na tela (junto com o tempo de processamento). . Tip Se pressionar o outro bot\u00e3o o uC ser\u00e1 reiniciado (reset). Note Reparou que o sistema de modo geral est\u00e1 muito lento? Vamos melhorar isso!","title":"Testando"},{"location":"mutirao/","text":"Sobre \u00b6 O mutir\u00e3o C \u00e9 composto por","title":"Sobre"},{"location":"mutirao/#sobre","text":"O mutir\u00e3o C \u00e9 composto por","title":"Sobre"}]}