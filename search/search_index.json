{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Bem vindo aos Laborat\u00f3rios de C \u00b6 Curso: Engenharia Da Computa\u00e7\u00e3o - Quinto Semestre Disciplinas: Computa\u00e7\u00e3o Embarcada/ Sistemas HW/SW e Desafios de Programa\u00e7\u00e3o Equipe: Rafael Corsi/ Igor Montagner/ Marcelo Hasimoto/ Eduardo Marossi/ Marco Mello \u00a9 Todos os direitos reservados Objetivos \u00b6 Capacitar os alunos na linguagem C para que possam usar nas disciplinas do Quinto Semestre da Eng. Computa\u00e7\u00e3o Insper. Motiva\u00e7\u00e3o \u00b6 C possui uma excelente performance \u00c9 uma das linguagens mais utilizadas no mundo: https://spectrum.ieee.org/static/interactive-the-top-programming-languages-2019 https://githut.info/ \u00c9 baixo n\u00edvel Pesquisa \u00b6 MONTAGNER, I. S.; FERRAO, R. C. ; MAROSSI, E. ; AYRES, F. J. . Teaching C programming in context: a joint effort between the Computer Systems, Embedded Computing and Programming Challenges courses. In: IEEE Frontiers in Education Conference (FIE), 2019, Cincinatti. 2019 IEEE Frontiers in Education Conference (FIE) Proceedings, 2019.","title":"Home"},{"location":"#bem-vindo-aos-laboratorios-de-c","text":"Curso: Engenharia Da Computa\u00e7\u00e3o - Quinto Semestre Disciplinas: Computa\u00e7\u00e3o Embarcada/ Sistemas HW/SW e Desafios de Programa\u00e7\u00e3o Equipe: Rafael Corsi/ Igor Montagner/ Marcelo Hasimoto/ Eduardo Marossi/ Marco Mello \u00a9 Todos os direitos reservados","title":"Bem vindo aos Laborat\u00f3rios de C"},{"location":"#objetivos","text":"Capacitar os alunos na linguagem C para que possam usar nas disciplinas do Quinto Semestre da Eng. Computa\u00e7\u00e3o Insper.","title":"Objetivos"},{"location":"#motivacao","text":"C possui uma excelente performance \u00c9 uma das linguagens mais utilizadas no mundo: https://spectrum.ieee.org/static/interactive-the-top-programming-languages-2019 https://githut.info/ \u00c9 baixo n\u00edvel","title":"Motiva\u00e7\u00e3o"},{"location":"#pesquisa","text":"MONTAGNER, I. S.; FERRAO, R. C. ; MAROSSI, E. ; AYRES, F. J. . Teaching C programming in context: a joint effort between the Computer Systems, Embedded Computing and Programming Challenges courses. In: IEEE Frontiers in Education Conference (FIE), 2019, Cincinatti. 2019 IEEE Frontiers in Education Conference (FIE) Proceedings, 2019.","title":"Pesquisa"},{"location":"day1-embarcados-parte2/","text":"Embarcados - Parte 2 \u00b6 Melhorando o desempenho \u00b6 Assim como qualquer sistema microprocessado podemos ajustar diversos par\u00e2metros interno de funcionamento do microcontrolador. Sendo o clock (frequ\u00eancia de opera\u00e7\u00e3o) um dos fatores que possui grande impacto na aplica\u00e7\u00e3o. \u00c9 natural pensarmos que quanto maior a frequ\u00eancia do clock maior ser\u00e1 o gasto energ\u00e9tico de um sistema, lembre de camada f\u00edsica onde vimos que o gasto energ\u00e9tico em sistemas digitais constru\u00eddos com MOSFET \u00e9: \\alpha C V_{DD}^2 f \\alpha C V_{DD}^2 f onde : \\alpha \\alpha : fator de chaveamento (influenciado pelo c\u00f3digo) C C : capacit\u00e2ncia V V : tens\u00e3o de opera\u00e7\u00e3o f f : frequ\u00eancia de chaveamento Portanto quanto maior a frequ\u00eancia de chaveamento maior ser\u00e1 o gasto energ\u00e9tico do sistema, mas um detalhe deve ser levado em considera\u00e7\u00e3o: quanto maior a frequ\u00eancia do clock mais r\u00e1pido uma tarefa \u00e9 realizada e mais rapidamente um sistema pode entrar em modo de baixo consumo energ\u00e9tico sleep mode, suspens\u00e3o, .... . Note Recentemente o kernel do linux removeu o perfil ondemand de seus modos de opera\u00e7\u00e3o , esse modo alterava dinamicamente a frequ\u00eancia de opera\u00e7\u00e3o do processador para alta quando uma grande carga de processamento era demandada e para mais baixa quando o processador estava em baixo uso. A ideia inicial disso era a melhoria do consumo energ\u00e9tico j\u00e1 que o processador se ajustava a demanda do sistema. Por\u00e9m detectou-se que isso n\u00e3o era verdade, j\u00e1 que esse modo tardava o processador de entrar no modo de sleep mais profundo al\u00e9m de demandar processamento para verificar a carga atual do processador. Alterando a frequ\u00eancia de opera\u00e7\u00e3o \u00b6 O arquivo .h localizado em: src/config/conf_clock.h \u00e9 respons\u00e1vel pela configura\u00e7\u00e3o do clock do microcontrolador. Note que no trecho de c\u00f3digo referente ao Prescaler existem diversas op\u00e7\u00f5es que podem ser escolhidas, a atual est\u00e1 definda como: // ===== Processor Clock (HCLK) Prescaler Options (Fhclk = Fsys / (SYSCLK_PRES)) //#define CONFIG_SYSCLK_PRES SYSCLK_PRES_1 //#define CONFIG_SYSCLK_PRES SYSCLK_PRES_2 //#define CONFIG_SYSCLK_PRES SYSCLK_PRES_4 //#define CONFIG_SYSCLK_PRES SYSCLK_PRES_8 //#define CONFIG_SYSCLK_PRES SYSCLK_PRES_16 //#define CONFIG_SYSCLK_PRES SYSCLK_PRES_32 #define CONFIG_SYSCLK_PRES SYSCLK_PRES_64 //#define CONFIG_SYSCLK_PRES SYSCLK_PRES_3 Onde Fsys \u00e9 equivalente a 300Mhz . Na configura\u00e7\u00e3o inicial a frequ\u00eancia do processador \u00e9 300Mhz/64 = 4.5 MHz, altere esse trecho para a forma a seguir, selecionando a frequ\u00eancia do principal do uC para 300Mhz. // ===== Processor Clock (HCLK) Prescaler Options (Fhclk = Fsys / (SYSCLK_PRES)) #define CONFIG_SYSCLK_PRES SYSCLK_PRES_1 //#define CONFIG_SYSCLK_PRES SYSCLK_PRES_2 //#define CONFIG_SYSCLK_PRES SYSCLK_PRES_4 //#define CONFIG_SYSCLK_PRES SYSCLK_PRES_8 //#define CONFIG_SYSCLK_PRES SYSCLK_PRES_16 //#define CONFIG_SYSCLK_PRES SYSCLK_PRES_32 //#define CONFIG_SYSCLK_PRES SYSCLK_PRES_64 //#define CONFIG_SYSCLK_PRES SYSCLK_PRES_3 Testando Compile e embarque o firmware com essa mudan\u00e7a. Verifique a nova taxa de atualiza\u00e7\u00e3o do LCD, melhorou? Como tudo isso funciona? \u00b6 Em uma vis\u00e3o mais geral podemos analisar o sistema como um kit de desenvolvimento e um display LCD: Sistema detalhado \u00b6 Uma an\u00e1lise mais detalhada do projeto pode ser visto no diagrama de blocos a seguir: Esse projeto \u00e9 implementando em um kit de desenvolvimento para microcontroladores ARM Cortex M7 do fabricante Microchip/ATMEL (a ARM n\u00e3o fabrica chips, somente propriedade intelectual). Esse microcontrolador \u00e9 chamado de SAME70 e o kit de desenvolvimento SAME70-XPLD . O kit possui al\u00e9m do microcontrolador toda a infraestrutura necess\u00e1ria para o seu funcionamento e mais alguns perif\u00e9ricos que podem ser \u00fateis no desenvolvimento de um projeto (gerenciador de energia, gravador, mem\u00f3ria, bot\u00e3o, led). Pelo diagrama detalhado nota-se que a comunica\u00e7\u00e3o do uC com o LCD \u00e9 realizado via uma interface serial (lembra da UART de Camada F\u00edsica? aqui usa-se uma outra comunica\u00e7\u00e3o similar chamada de SPI ). No m\u00f3dulo do LCD um chip dedicado para o controle do display ( ili9488 , da mesma fam\u00edlia do display de elementos de sistema) recebe instru\u00e7\u00f5es do uC e atualiza o LCD. Note Microcontroladores n\u00e3o necessitam geralmente de mem\u00f3ria externa para o seu funcionamento, por\u00e9m \u00e9 a mesma deve sert utilizada quando a aplica\u00e7\u00e3o necessita de uma quantidade razo\u00e1vel de mem\u00f3ria. No caso desse microcontrolador possui internamente \"somente\": 384 KBytes de RAM 2 MBytes de ROM \"somente\" se compararmos com a capacidade de armazenamento de um computador, mas se compararmos com outros microcontroladores esse possui muita mem\u00f3ria. Essa memoria interna do uC n\u00e3o foi suficiente para a nossa aplica\u00e7\u00e3o de exemplo, tivermos que recorrer a essa mem\u00f3ria externa (SDRAM). microcontrolador \u00b6 Podemos detalhar ainda mais o sistema se detalharmos o que est\u00e1 sendo usado no microcontrolador, entendendo todas as partes em uso. Pelo diagrama podemos notar os seguintes \"perif\u00e9ricos\": CORE M7: Unidade de processamento ARM. RAM: Unidade de mem\u00f3ria que \u00e9 usada durante execu\u00e7\u00e3o (vari\u00e1veis). ROM: Unidade de mem\u00f3ria usada para armazenar o programa e constantes . External Memory Controller: Perif\u00e9rico respons\u00e1vel por gerenciar uma mem\u00f3ria externa. SPI: Perif\u00e9rico respons\u00e1vel pela comunica\u00e7\u00e3o serial SPI e interface com o m\u00f3dulo LCD. PIO: Perif\u00e9rico respons\u00e1vel pela interface com entradas e sa\u00eddas digitais (Parallel Input/OutPut). . Firmware \u00b6 O arquivo principal desse projeto \u00e9 o main.c (\u00e9 muito comum em C a fun\u00e7\u00e3o main() estar no arquivo main.c, mas n\u00e3o \u00e9 necess\u00e1rio), esse c\u00f3digo fonte possui a fun\u00e7\u00e3o main() que \u00e9 a primeira a ser chamada na inicializa\u00e7\u00e3o do sistema. Nessa fun\u00e7\u00e3o inicializa-se primeiro o sistema embarcado e seus perif\u00e9ricos (clock, LCD, bot\u00e3o, mem\u00f3ria) via a chamada de fun\u00e7\u00e3o initBoardMutirao() . Ap\u00f3s inicializado a placa chama-se a fun\u00e7\u00e3o imgshow(...) que possui toda a parte respons\u00e1vel por exibir a imagem no LCD. Trecho do arquivo main.c int main (){ uint32_t time ; // variavel para armazenar tempo de processamento uint8_t imageSelect = 1 ; // variavle para selecao da imagem a ser exibida // quando o botao for pressionado // 1 = imagem processada // 0 = imagem orignal // inicializa placa e seus perifericos initBoardMutirao (); // exibe imagem orignal, tempo de processamento suprimido. imgShow ( imgRaw , 0 ); ... A fun\u00e7\u00e3o imgShow possui dois par\u00e2metros: a imagem image[320][320] a ser exibida, passada como uma matriz de tamanho j\u00e1 definido, e o tempo de processamento a ser exibido no LCD: void imgShow ( ili9488_color_t image [ 320 ][ 320 ], uint32_t time ){...} Ap\u00f3s essa etapa o microcontrolador entra em um loop infinito ( while(1){} ) que verifica uma vari\u00e1vel chamada de buttonFlag que \u00e9 alterada via uma interrup\u00e7\u00e3o para o valor 1 sempre que o bot\u00e3o for pressionado. // super loop // aplicacoes embarcadas n\u00e3o devem sair do while(1). while ( 1 ) { // se buttonFlag = 1 existe alteracao no estado do botao if ( buttonFlag ){","title":"Embarcados - Parte 2"},{"location":"day1-embarcados-parte2/#embarcados-parte-2","text":"","title":"Embarcados - Parte 2"},{"location":"day1-embarcados-parte2/#melhorando-o-desempenho","text":"Assim como qualquer sistema microprocessado podemos ajustar diversos par\u00e2metros interno de funcionamento do microcontrolador. Sendo o clock (frequ\u00eancia de opera\u00e7\u00e3o) um dos fatores que possui grande impacto na aplica\u00e7\u00e3o. \u00c9 natural pensarmos que quanto maior a frequ\u00eancia do clock maior ser\u00e1 o gasto energ\u00e9tico de um sistema, lembre de camada f\u00edsica onde vimos que o gasto energ\u00e9tico em sistemas digitais constru\u00eddos com MOSFET \u00e9: \\alpha C V_{DD}^2 f \\alpha C V_{DD}^2 f onde : \\alpha \\alpha : fator de chaveamento (influenciado pelo c\u00f3digo) C C : capacit\u00e2ncia V V : tens\u00e3o de opera\u00e7\u00e3o f f : frequ\u00eancia de chaveamento Portanto quanto maior a frequ\u00eancia de chaveamento maior ser\u00e1 o gasto energ\u00e9tico do sistema, mas um detalhe deve ser levado em considera\u00e7\u00e3o: quanto maior a frequ\u00eancia do clock mais r\u00e1pido uma tarefa \u00e9 realizada e mais rapidamente um sistema pode entrar em modo de baixo consumo energ\u00e9tico sleep mode, suspens\u00e3o, .... . Note Recentemente o kernel do linux removeu o perfil ondemand de seus modos de opera\u00e7\u00e3o , esse modo alterava dinamicamente a frequ\u00eancia de opera\u00e7\u00e3o do processador para alta quando uma grande carga de processamento era demandada e para mais baixa quando o processador estava em baixo uso. A ideia inicial disso era a melhoria do consumo energ\u00e9tico j\u00e1 que o processador se ajustava a demanda do sistema. Por\u00e9m detectou-se que isso n\u00e3o era verdade, j\u00e1 que esse modo tardava o processador de entrar no modo de sleep mais profundo al\u00e9m de demandar processamento para verificar a carga atual do processador.","title":"Melhorando o desempenho"},{"location":"day1-embarcados-parte2/#alterando-a-frequencia-de-operacao","text":"O arquivo .h localizado em: src/config/conf_clock.h \u00e9 respons\u00e1vel pela configura\u00e7\u00e3o do clock do microcontrolador. Note que no trecho de c\u00f3digo referente ao Prescaler existem diversas op\u00e7\u00f5es que podem ser escolhidas, a atual est\u00e1 definda como: // ===== Processor Clock (HCLK) Prescaler Options (Fhclk = Fsys / (SYSCLK_PRES)) //#define CONFIG_SYSCLK_PRES SYSCLK_PRES_1 //#define CONFIG_SYSCLK_PRES SYSCLK_PRES_2 //#define CONFIG_SYSCLK_PRES SYSCLK_PRES_4 //#define CONFIG_SYSCLK_PRES SYSCLK_PRES_8 //#define CONFIG_SYSCLK_PRES SYSCLK_PRES_16 //#define CONFIG_SYSCLK_PRES SYSCLK_PRES_32 #define CONFIG_SYSCLK_PRES SYSCLK_PRES_64 //#define CONFIG_SYSCLK_PRES SYSCLK_PRES_3 Onde Fsys \u00e9 equivalente a 300Mhz . Na configura\u00e7\u00e3o inicial a frequ\u00eancia do processador \u00e9 300Mhz/64 = 4.5 MHz, altere esse trecho para a forma a seguir, selecionando a frequ\u00eancia do principal do uC para 300Mhz. // ===== Processor Clock (HCLK) Prescaler Options (Fhclk = Fsys / (SYSCLK_PRES)) #define CONFIG_SYSCLK_PRES SYSCLK_PRES_1 //#define CONFIG_SYSCLK_PRES SYSCLK_PRES_2 //#define CONFIG_SYSCLK_PRES SYSCLK_PRES_4 //#define CONFIG_SYSCLK_PRES SYSCLK_PRES_8 //#define CONFIG_SYSCLK_PRES SYSCLK_PRES_16 //#define CONFIG_SYSCLK_PRES SYSCLK_PRES_32 //#define CONFIG_SYSCLK_PRES SYSCLK_PRES_64 //#define CONFIG_SYSCLK_PRES SYSCLK_PRES_3 Testando Compile e embarque o firmware com essa mudan\u00e7a. Verifique a nova taxa de atualiza\u00e7\u00e3o do LCD, melhorou?","title":"Alterando a frequ\u00eancia de opera\u00e7\u00e3o"},{"location":"day1-embarcados-parte2/#como-tudo-isso-funciona","text":"Em uma vis\u00e3o mais geral podemos analisar o sistema como um kit de desenvolvimento e um display LCD:","title":"Como tudo isso funciona?"},{"location":"day1-embarcados-parte2/#sistema-detalhado","text":"Uma an\u00e1lise mais detalhada do projeto pode ser visto no diagrama de blocos a seguir: Esse projeto \u00e9 implementando em um kit de desenvolvimento para microcontroladores ARM Cortex M7 do fabricante Microchip/ATMEL (a ARM n\u00e3o fabrica chips, somente propriedade intelectual). Esse microcontrolador \u00e9 chamado de SAME70 e o kit de desenvolvimento SAME70-XPLD . O kit possui al\u00e9m do microcontrolador toda a infraestrutura necess\u00e1ria para o seu funcionamento e mais alguns perif\u00e9ricos que podem ser \u00fateis no desenvolvimento de um projeto (gerenciador de energia, gravador, mem\u00f3ria, bot\u00e3o, led). Pelo diagrama detalhado nota-se que a comunica\u00e7\u00e3o do uC com o LCD \u00e9 realizado via uma interface serial (lembra da UART de Camada F\u00edsica? aqui usa-se uma outra comunica\u00e7\u00e3o similar chamada de SPI ). No m\u00f3dulo do LCD um chip dedicado para o controle do display ( ili9488 , da mesma fam\u00edlia do display de elementos de sistema) recebe instru\u00e7\u00f5es do uC e atualiza o LCD. Note Microcontroladores n\u00e3o necessitam geralmente de mem\u00f3ria externa para o seu funcionamento, por\u00e9m \u00e9 a mesma deve sert utilizada quando a aplica\u00e7\u00e3o necessita de uma quantidade razo\u00e1vel de mem\u00f3ria. No caso desse microcontrolador possui internamente \"somente\": 384 KBytes de RAM 2 MBytes de ROM \"somente\" se compararmos com a capacidade de armazenamento de um computador, mas se compararmos com outros microcontroladores esse possui muita mem\u00f3ria. Essa memoria interna do uC n\u00e3o foi suficiente para a nossa aplica\u00e7\u00e3o de exemplo, tivermos que recorrer a essa mem\u00f3ria externa (SDRAM).","title":"Sistema detalhado"},{"location":"day1-embarcados-parte2/#microcontrolador","text":"Podemos detalhar ainda mais o sistema se detalharmos o que est\u00e1 sendo usado no microcontrolador, entendendo todas as partes em uso. Pelo diagrama podemos notar os seguintes \"perif\u00e9ricos\": CORE M7: Unidade de processamento ARM. RAM: Unidade de mem\u00f3ria que \u00e9 usada durante execu\u00e7\u00e3o (vari\u00e1veis). ROM: Unidade de mem\u00f3ria usada para armazenar o programa e constantes . External Memory Controller: Perif\u00e9rico respons\u00e1vel por gerenciar uma mem\u00f3ria externa. SPI: Perif\u00e9rico respons\u00e1vel pela comunica\u00e7\u00e3o serial SPI e interface com o m\u00f3dulo LCD. PIO: Perif\u00e9rico respons\u00e1vel pela interface com entradas e sa\u00eddas digitais (Parallel Input/OutPut). .","title":"microcontrolador"},{"location":"day1-embarcados-parte2/#firmware","text":"O arquivo principal desse projeto \u00e9 o main.c (\u00e9 muito comum em C a fun\u00e7\u00e3o main() estar no arquivo main.c, mas n\u00e3o \u00e9 necess\u00e1rio), esse c\u00f3digo fonte possui a fun\u00e7\u00e3o main() que \u00e9 a primeira a ser chamada na inicializa\u00e7\u00e3o do sistema. Nessa fun\u00e7\u00e3o inicializa-se primeiro o sistema embarcado e seus perif\u00e9ricos (clock, LCD, bot\u00e3o, mem\u00f3ria) via a chamada de fun\u00e7\u00e3o initBoardMutirao() . Ap\u00f3s inicializado a placa chama-se a fun\u00e7\u00e3o imgshow(...) que possui toda a parte respons\u00e1vel por exibir a imagem no LCD. Trecho do arquivo main.c int main (){ uint32_t time ; // variavel para armazenar tempo de processamento uint8_t imageSelect = 1 ; // variavle para selecao da imagem a ser exibida // quando o botao for pressionado // 1 = imagem processada // 0 = imagem orignal // inicializa placa e seus perifericos initBoardMutirao (); // exibe imagem orignal, tempo de processamento suprimido. imgShow ( imgRaw , 0 ); ... A fun\u00e7\u00e3o imgShow possui dois par\u00e2metros: a imagem image[320][320] a ser exibida, passada como uma matriz de tamanho j\u00e1 definido, e o tempo de processamento a ser exibido no LCD: void imgShow ( ili9488_color_t image [ 320 ][ 320 ], uint32_t time ){...} Ap\u00f3s essa etapa o microcontrolador entra em um loop infinito ( while(1){} ) que verifica uma vari\u00e1vel chamada de buttonFlag que \u00e9 alterada via uma interrup\u00e7\u00e3o para o valor 1 sempre que o bot\u00e3o for pressionado. // super loop // aplicacoes embarcadas n\u00e3o devem sair do while(1). while ( 1 ) { // se buttonFlag = 1 existe alteracao no estado do botao if ( buttonFlag ){","title":"Firmware"},{"location":"day1-embarcados/","text":"Embarcados - Parte 1 \u00b6 Warning Essa atividade demanda sistema operacional Windows, conforme descrito na infra de Computa\u00e7\u00e3o Embarcada Nessa aula iremos trabalhar com os conceitos b\u00e1sicos da linguagem C aplicados ao processamento de imagem em sistemas embarcados. Para isso utilizaremos um kit de desenvolvimento com um microcontrolador ARM cortex M7 e um LCD colorido de 480x320 px conectado a esse kit. Detalhe do material utilizado Kit : SAME70-XPLD Microcontrolador : ARM Cortex M7 LCD : maXTouch Xplained Pro Parte 1 \u00b6 Nesse primeira etapa iremos executar um c\u00f3digo exemplo no sistema embarcado, para isso ser\u00e1 necess\u00e1rio: Conectar o LCD ao kit Conectar o kit no computador Abrir e compilar o projeto no AtmelStudio Programar o microcontrolador Validar o resultado esperado Antes de prosseguir voc\u00ea deve ter o reposit\u00f3rio Labs C j\u00e1 clonado no seu computador (Windows). Conectando o LCD \u00b6 Warning Tome cuidado ao manusear a placa, n\u00e3o coloque ela sobre outros materiais. Considerando que os pr\u00e9 requisitos para a disciplina de Computa\u00e7\u00e3o Embarcada j\u00e1 foram instalados. Conectar o USB do programador no computador: Tip Note que a placa possui dois USB: DEBUG USB , usado para programar o uC e TARGET USB usado para projetos que demandam conectividade via USB. AtmelStudio \u00b6 Abra o projeto exemplo ( SAME70-MutiraoC ) localizado no reposit\u00f3rio do mutir\u00e3o http://github.com/insper/MutiraoC/01-DayOne/SAEM70-MutiraoC O projeto ir\u00e1 abrir na IDE do AtmelStudio como imagem a seguir: . Compilar e programar \u00b6 A etapa atual ser\u00e1 a de embarcar o c\u00f3digo exemplo no uC, para isso basta clicar em Start Without Debug : . Testando \u00b6 Uma vez embarcado o exemplo o LCD dever\u00e1 exibir uma imagem. A primeira imagem que aparece \u00e9 a imagem original sem nenhum tipo de modifica\u00e7\u00e3o, ao apertar o bot\u00e3o SW0 do kit de desenvolvimento uma fun\u00e7\u00e3o ( imageProcess() ) \u00e9 chamada e a imagem orignal \u00e9 processada e seu resultado exibido na tela (junto com o tempo de processamento). . Tip Se pressionar o outro bot\u00e3o o uC ser\u00e1 reiniciado (reset). Note Reparou que o sistema de modo geral est\u00e1 muito lento? Vamos melhorar isso!","title":"Embarcados - Parte 1"},{"location":"day1-embarcados/#embarcados-parte-1","text":"Warning Essa atividade demanda sistema operacional Windows, conforme descrito na infra de Computa\u00e7\u00e3o Embarcada Nessa aula iremos trabalhar com os conceitos b\u00e1sicos da linguagem C aplicados ao processamento de imagem em sistemas embarcados. Para isso utilizaremos um kit de desenvolvimento com um microcontrolador ARM cortex M7 e um LCD colorido de 480x320 px conectado a esse kit. Detalhe do material utilizado Kit : SAME70-XPLD Microcontrolador : ARM Cortex M7 LCD : maXTouch Xplained Pro","title":"Embarcados - Parte 1"},{"location":"day1-embarcados/#parte-1","text":"Nesse primeira etapa iremos executar um c\u00f3digo exemplo no sistema embarcado, para isso ser\u00e1 necess\u00e1rio: Conectar o LCD ao kit Conectar o kit no computador Abrir e compilar o projeto no AtmelStudio Programar o microcontrolador Validar o resultado esperado Antes de prosseguir voc\u00ea deve ter o reposit\u00f3rio Labs C j\u00e1 clonado no seu computador (Windows).","title":"Parte 1"},{"location":"day1-embarcados/#conectando-o-lcd","text":"Warning Tome cuidado ao manusear a placa, n\u00e3o coloque ela sobre outros materiais. Considerando que os pr\u00e9 requisitos para a disciplina de Computa\u00e7\u00e3o Embarcada j\u00e1 foram instalados. Conectar o USB do programador no computador: Tip Note que a placa possui dois USB: DEBUG USB , usado para programar o uC e TARGET USB usado para projetos que demandam conectividade via USB.","title":"Conectando o LCD"},{"location":"day1-embarcados/#atmelstudio","text":"Abra o projeto exemplo ( SAME70-MutiraoC ) localizado no reposit\u00f3rio do mutir\u00e3o http://github.com/insper/MutiraoC/01-DayOne/SAEM70-MutiraoC O projeto ir\u00e1 abrir na IDE do AtmelStudio como imagem a seguir: .","title":"AtmelStudio"},{"location":"day1-embarcados/#compilar-e-programar","text":"A etapa atual ser\u00e1 a de embarcar o c\u00f3digo exemplo no uC, para isso basta clicar em Start Without Debug : .","title":"Compilar e programar"},{"location":"day1-embarcados/#testando","text":"Uma vez embarcado o exemplo o LCD dever\u00e1 exibir uma imagem. A primeira imagem que aparece \u00e9 a imagem original sem nenhum tipo de modifica\u00e7\u00e3o, ao apertar o bot\u00e3o SW0 do kit de desenvolvimento uma fun\u00e7\u00e3o ( imageProcess() ) \u00e9 chamada e a imagem orignal \u00e9 processada e seu resultado exibido na tela (junto com o tempo de processamento). . Tip Se pressionar o outro bot\u00e3o o uC ser\u00e1 reiniciado (reset). Note Reparou que o sistema de modo geral est\u00e1 muito lento? Vamos melhorar isso!","title":"Testando"}]}